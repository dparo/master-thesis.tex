\chapter{Implementation}

\mytodo{Introduce the project, say it is written in C, point to the github repo url, etc...}

\section{Introduction to CPLEX}

\mytodo{Explain what is CPLEX, academic license, url where it can be downloaded etc}


\section{Full static model}

In this section we present the full static model that we implemented.

\begin{align}
	\min_{x,y} \quad z(x, y) & = \ExprCptpObjValDef                                                       \\
	                         & y_0 = 1                                  &                                 \\
	                         & \ExprCptpEdgesIncident{i}    = 2 y_i     & \quad \forall i \in V           \\
	                         & B \le   \ExprCptpDemandSum   \le Q       &                                 \\
	                         & x_{ij}                   \in \Set*{0, 1} & \quad \forall (i, j) \in E      \\
	                         & y_{i}                    \in \Set*{0, 1} & \quad \forall i \in V,\ i \ge 1
\end{align}

which follows closely the full IP formulation presented in \eqref{eq:obj-function} without the GSECs.
We also added a non strictly necessary lower bound on the served demand, which details were already discussed earlier in Section \ref{sec:demand-lower-bound}.

\section{Cutoff values}


\subsection{Upper cutoff value}
Since we're interested in solving the CPTP in the context of pricing for the CVRP, we're only searching for tours achieving a strictly negative objective value.
Therefore, we can specify an upper cutoff for the objective function $z(x, y)$:

\begin{equation}
	z(x, y) \le 0 - \varepsilon_{\mt{ct}}
\end{equation}

where $\varepsilon_{\mt{ct}} \in \R$ is the upper cutoff tolerance, in our implementation we picked $\varepsilon_{\mt{ct}} = 10^{-6}$, which is the default used in BapCod.

The upper cutoff value can improve the linear relaxation and reduce the number of branch and bound nodes that need to be explored, especially when the MIP solver cannot infer any good starting primal solution.

\subsection{Lower cutoff value}
A good lower cutoff value on the objective function can improve the linear relaxation, and reduce the number of branch and bounds nodes that need to be explored.
When combined with an upper cutoff value, and a good set of warm start solutions it can help to start the solution process with an already relatively closed gap.

A lower cutoff value can be obtained by any feasible dual solution.
For example we could use the method briefly described in Section \ref{sec:cptp-simple-dual-formulation} to obtain a feasible lower bound.
At the time of writing of this draft report, the method described in Section \ref{sec:cptp-simple-dual-formulation} was not extensively explored.

Instead, we opted for a much simpler approach:

\begin{equation}
	z(x, y) \ge - \sum_{i \in V} p_i
\end{equation}

which is describes a very weak lower bound, and in pretty much all cases, is easily improved in the preprocessing stage of a standard MIP solver.

\section{Warm start}

Heuristic algorithms can be used to provide good feasible primal solutions to the MIP.
A CPTP problem has many similarities with TSP, therefore heuristics for the TSP, if slightly adapted, ca be applied successfully to this problem domain.
Much work was dedicated in studying good heuristics for the TSP, see \cite{rosenkrantz_analysis_1977}, \cite{johnson_traveling_1997}, \cite{laporte_traveling_1992}, \cite{johnson_experimental_2007}, \cite{hoffman_traveling_2013}.

In the remainder of this section we explain the implemented warm start procedure which is characterized by two stage: a constructive insertion heuristic stage followed by a 2-OPT refinement stage.

\subsection{Insertion heuristic}
\cite{rosenkrantz_analysis_1977} do a fantastic job describing the insertion heuristic algorithm for the TSP and various facets in which it can be implemented.
The insertion heuristic algorithm can construct a new feasible primal solutions in $\Theta(N^2)$ time.

In this section, we will focus on adapting the insertion heuristic for the TSP so that it can be applied to CPTP problems.
Start by selecting two distinct nodes $s, t \in V,\ q_s + q_t \le Q$ and use these two nodes to form a tour back-to-back.

The insertion heuristic algorithm works iteratively where, at each step of the iteration, we have a valid tour not necessarily feasible for the CPTP.
At the end of the whole algorithm, the final obtained tour will be CPTP feasible (if any exist).
Let's define $Q_t \le Q$ as the total demand served in the current tour.
At each iteration, choose a vertex $a$ that belongs to the current tour and a vertex $h$ which is not yet part of the tour.
Let's define $b$ as the successor of node $a$ in the current tour.
The idea is to try to insert $h$ in the current tour, by deleting edge $(a, b)$, and inserting edges $(a, h),\ (h, b)$ but only if $h$ must be inserted or improves over the current tour.
Let's define the extra mileage as
:
\begin{equation}
	\Delta_m(h, a) =
	\begin{cases}
		d_{ah} + d_{hb} - d_{ab} - p_h, & \texttt{if } Q_t + q_h \le Q \\
		\infty,                         & \texttt{otherwise}
	\end{cases}
\end{equation}

which represents the delta cost in inserting $h$ as the successor of $a$.
A node $h$ is a good candidate for insertion if at least one of the following conditions is true:
\begin{enumerate}
	\item $\Delta_m(h, a) < 0$, i.e. inserting $h$ improves over the current tour.
	\item $h = 0$, i.e. $h$ is the depot node. The depot node at some point must be inserted regardless whether it is improving or not.
	      Note that by convention we have defined $q_0 = 0$, therefore $Q_t + q_0 \le Q$ is always satisfied for the depot node.
	\item The number of visited nodes in the current tour is $2$ and $Q_t + q_h \le Q$.
\end{enumerate}

In our implementation we employed a cheapest insertion scheme, therefore the pair $(h, a)$ for the current insertion iteration is picked such that it minimizes as much as possible the extra mileage $\Delta_m(h, a)$.
The iteration stops when no more valid $h$ vertices can be found for insertion.
It may happen that no valid $h$ can be found, yet the current tour length is $2$.
In this very unlikely scenario, we can conclude that the CPTP formulation does not admit any feasible solution before even solving the IP formulation.

In our implementation we picked $s = 0$ and $t \in V_0$, such that $q_s + q_t \le Q$.
This allows us to generate $O(N)$ good feasible primal solutions using insertion heuristic in $O(N^3)$ time.

\subsection{2-OPT refinement}
In our implementation, each solution produced from the insertion heuristic is further improved using a 2-OPT refinement procedure.
The 2-OPT algorithm is a heuristic local-search hill-climbing procedure proposed originally for the TSP in \cite{flood_traveling-salesman_1956}, \cite{croes_method_1958}.

An application of the 2-OPT algorithm works iteratively requiring $\Omega(N^2)$ time.
Unfortunately, as it is pointed out in \cite{chandra_new_1999}, the 2-OPT algorithm may in the worst case take an exponential number of iterations when fed with purposely artificially constructed instances.
Although this is bad news, it is also worth pointing out that this rarely occur in practice, as the probabilistic average number of iterations required for 2-OPT is at most polynomial.

Each iteration of the 2-OPT procedure searches for an existing edge crossing, and if any exists, it performs a 2-OPT exchange to undo it.
A 2-OPT exchange always maintain the original feasibility, therefore if the 2-OPT algorithm is applied on a feasible solution, it will remain feasible at the end of the whole procedure.
We briefly describe the 2-OPT exchange.
Let $a, b \in V$ be two vertices visited in the current tour, and let's use $a_s, b_s \in V$ to denote respectively the successor of $a$ and $b$ in the current tour.
A 2-OPT exchange removes edges $(a, a_s)$, $(b, b_s)$ in favor of $(a, b)$, $(a_s, b_s)$ but only if the delta distance defined as:

\begin{equation}
	\Delta(a, b) = d_{ab} + d_{a_sb_s} - d_{aa_s} - d_{bb_s}
\end{equation}

satisfies $\Delta(a, b) < 0$.
If this is the case, performing a 2-OPT exchange over vertices $(a, b)$ can improve the current tour.
After the 2-OPT exchange it is necessary to reverse part of the tour characterized from the head $a_s$ and tail $b$: $[a_s, \dots, b]$.

In our implementation we scan for vertices $a, b$ achieving the cheapest exchange, i.e. for which $\Delta(a, b)$ is minimized across all possible valid choices of $a, b$.


\section{Separation techniques}

Inequality separation is a problem which consists in finding (strong) violated inequalities so that they can be embedded inside a Branch\&Cut framework.
Integral inequality separation is concerned in determining violated inequalities for the original IP model.
Integral inequalities separation is usually much easier to perform, and can be seen as a procedure to dynamically generate necessary constraints that would otherwise be impossible to insert statically in a MIP model.
Fractional inequality separation, instead is usually harder to perform, and it is concerned in finding (strong) violated inequalities for fractional solutions originated from the linear relaxation.

In this thesis we are treating a CPTP problem, and more precisely, we are concerned in separating the GSEC, GLM, RCI inequalities presented in Sections \ref{sec:gsec-inequality}, \ref{sec:additional-valid-inequalities}.
This is achieved by finding sets $S \subseteq V_0$, through the usage of appropriate algorithms, that violate any valid inequality.

All the cuts that we implemented, are backed by the same shared separation procedure for both integral solutions and for fractional solutions.
In the next two sections, we describe the common separation procedure used to find good $S \subseteq V_0$ sets.
Then for each cut, we describe: how $S$ is used for generating the inequality and when each cut is reported to the MIP solver or when it is, instead, ignored.

\subsection{Integral separation}\label{sec:integral-separation}
The integral separation procedure is the most important, as this procedure is necessary to generate GSEC inequalities dynamically, which have the effect of rejecting solutions containing spurious unconnected subtours.
Assume that the MIP solver finds an optimal integer solution $x^* \in \Set*{0, 1}, y^* \in \Set*{0, 1}$ that violates a GSEC constraint.
If $x^*$ violates at least a GSEC, it is easy to see that the solution models at least a spurious unconnected subtour that needs to be removed.
In order to detect unconnected subtours, we need first to determine the connected components induced from the $x^*$ solution.

Let $C = \Set*{-1, 0, \dots, n_c - 1}$ be the connected components formed with $n_c \ge 1$.
A node $i$ is said to belong to a singleton connected components, if the connected component contains only $i$ itself.
We are only interested in modeling \textbf{major} connected components, i.e. components containing at least two vertices.
Therefore, we ignore singleton connected components, and we use the sentinel value $-1$ for all the nodes $i$ belonging to singletons.
Thus, the $n_c$ represents the number of major connected components, i.e. the number of subtours formed in the current integral solution.
Let $cc(i) \in C$ be an array which for each vertex $i \in V$ it encodes to which connected component it belongs to.
Note that the depot node always belongs to a connected component, therefore by definition we fix $cc(0) = 0$.
For singletons instead we fix $c(i) = -1  \quad \forall i \in V_0 \mid y_i = 0$.
The connected components can be computed by a simple depth first search traversal, for which a pseudocode is provided in Algorithm \ref{algo:cc-dfs}.

\begin{algorithm}
	\label{algo:cc-dfs}
    \caption{An algorithm for computing the connected components through a DFS traversal}
    \KwData{$x^*, y^* \in \{0, 1\}$: current optimal integer solution}
    \KwResult{$n_c$: number of subtours formed}
    \KwResult{$cc[i] \in C$: connected component of $\forall i \in V$}
    \input{Content/Chapters/Snippets/cc-dfs-pseudoalgo.tex}
\end{algorithm}

Then any valid set $S \in V_0$ can be computed in the following way from a MIP integer solution:

\begin{equation}
	S \subseteq V_0 = \Set* {i \mid cc(i) = k}   \quad \forall k \in C, k > 0
\end{equation}

which implies that any major connected component that does not contain the depot node, can be used as a valid set $S \subseteq V_0$ for separating inequalities.
If $n_c = 1$ then no $S \subseteq V_0$ can be separated for this integral solution, which in our case simply means that the solution contains a single subtour, and does not violate any GSECs.


\subsection{Fractional separation}\label{sec:fractional-separation}
Fractional separation is usually much harder and more computationally expensive to perform compared to integral separation.
A valid set $S \subseteq V_0$ can be separated by solving a max-flow problem between two arbitrary source and sink vertices $s, t \in V,\ s \ne t$ on a fully connected directed graph.
Fractional separation is modeled through a directed symmetric flow network, where $x^*_{ij}$, i.e. the current fractional solution, constitutes the capacities of the flow network.


A solution to the max-flow problem outputs a maxflow $\maxflow(s, t)$ and a bipartition, also called "coloring", of the set $V$, namely two complementary sets $F_1(s, t), F_2(s, t)$ such that $F_1(s, t) \cup F_2(s, t) = V$ and $F_1 \cap F_2 = \emptyset$, and such that $s \in F_1(s, t),\ t \in F_2(s, t)$.
The $\delta(F_1(s, t))$ constitutes the min-cut induced from solving the max-flow problem over $(s, t)$.
It is known that solving a maxflow problem guarantees the following two properties:

\begin{enumerate}
	\item Edges $\{ (i, j) \mid i \in F_1(s, t),\ j \in F_2(s, t) \}$ are saturated
	\item Edges $\{ (j, i) \mid i \in F_1(s, t),\ j \in F_2(s, t) \}$ are drained.
\end{enumerate}

therefore the following result holds:
\begin{align}
	\sum_{(i, j) \in \delta(F_1(s, t))} f_{ij} & = \maxflow(s, t) \\
	\sum_{(i, j) \in \delta(F_2(s, t))} f_{ij} & = 0
\end{align}

where $f_{ij}$ denotes the flow along the edge $(i, j),\ i, j \in V$ in the corresponding flow network.
Assuming we have already computed $F_1(s, t), F_2(s, t)$, a valid $S \subseteq V_0$ can then be picked such that:
\begin{equation}
	S \subseteq V_0 =
	\begin{cases}
		F_1(s, t), & \texttt{if } 0 \notin F_1(s, t) \\
		F_2(s, t), & \texttt{otherwise}
	\end{cases}
\end{equation}

This fractional separation framework based on max-flow computations, can separate up to $N^2 - N$ different $S \subseteq V_0$ sets, one for each possible choice of $s, t \in V, s \ne t$.
It is important to note that, since we are dealing with a \textbf{symmetrical} flow network, solving the maxflow problem between pairs $(s, t)$ and pair $(t, s)$ will output the same maxflow, i.e. $\maxflow(s, t) = \maxflow(t, s)$.
Although, and this is the more important aspect, the induced bipartitions in the general case are not guaranteed to be symmetric.
Namely, in general, $F_1(s, t) \ne F_2(t, s)$ and $F_2(s, t) \ne F_1(t, s)$.
To see this is the case, this simple flow network:

\begin{center}
	\begin{tikzpicture}[node distance={20mm}, main/.style = {draw, circle, fill=black!10!white}]
		\centering

		\node[main] (0) {$0$};
		\node[main] (1) [right of = 0] {$1$};
		\node[main] (2) [right of = 1] {$2$};
		\node[main] (3) [right of = 2] {$3$};
		\node[main] (4) [right of = 3] {$4$};

		\draw (0) --  (1) node [midway, yshift=2mm] {$0$};
		\draw (1) --  (2) node [midway, yshift=2mm] {$10$};
		\draw (2) --  (3) node [midway, yshift=2mm] {$10$};
		\draw (3) --  (4) node [midway, yshift=2mm] {$0$};
	\end{tikzpicture}
\end{center}

produces the same max flow when solving for $(0, 4)$ and $(4, 0)$ pair respectively, and produces $F_1(0, 4) = \{ 0\},\ F_2(0, 4) = \{ 1, 2, 3, 4\}$, $F_1(4, 0) = \{ 4 \},\ F_2(4, 0) = \{ 0, 1, 2, 3\}$, which clearly represent a non symmetric coloring.
This behaviour is a direct consequence that flow networks don't guarantee unique min-cuts.

In this thesis, we used the push relabel max flow algorithm first developed in \cite{goldberg_efficient_1997}, which is usually faster than more classical approaches such as the Ford-Fulkerson max-flow algorithm.
The push relabel max flow algorithm runs in $O(N^4)$ time, and when combined with an exhaustive enumeration over all possible choices of $s, t$, can take up to $O(N^6)$ time.

The Gomory-Hu tree, first presented in \cite{gomory_multi-terminal_1961}, provides a way to compute the all pairs $(s, t)$ max-flows using only $N$ main max-flow computations.
A Gomory-Hu tree can be seen as a data structure that represents a simpler reduced flow network, where max-flow computations become trivially solvable through a single iteration of the Ford-Fulkerson algorithm in $\Theta(N^2)$.
Combining Gomory-Hu trees and the push relabel max flow algorithm, an exhaustive enumeration of all possible $(s, t)$ vertices takes up to $O(N^5)$ time to build the tree, and further $\Theta(N^4)$ to query for all the possible $F_1(s, t), F_2(s, t)$ bipartitions.

In this implementation we employed the usage of both the push relabel algorithm, the Gomory-Hu tree and full enumeration of all possible $(s, t)$ vertices.
Since running this full enumeration over each fractional separation, turned out to be quite costly, we decided to amortize the cost over multiple iterations.
Namely, fractional separations iterations which are not multiple of $N$ become a no-op, no max-flow is performed, and therefore no set $S \subseteq V_0$ is separated.

While there may be other ways to separate sets $S \subseteq V_0$, the described approach works very well for the inequalities considered in this thesis.
This is very convenient because a single separation procedure for $S \subseteq V_0$ can be shared across all the inequalities, thus reducing computation time.
Other kinds of inequalities, which are not considered in this thesis, may benefit from other more elaborate separation techniques.

We conclude the section by pointing out that writing fast and correct max-flow algorithms that operate with floating point arithmetic can be difficult and error-prone, since most operations become non-exact.
Any trivial implementation may "get stuck" in massively long loops pushing atomically small quantity of flows.
Careful attention must be paid when developing one such algorithm.
Good software engineering practices, such as unit testing, can help in spotting problematic implementations.

In the following sections we describe how we separate each inequality using the computed $S \subseteq V_0$.

\subsection{GSEC separation}

\subsubsection{GSEC integral separation}\label{sec:gsec-integral-separation}
This is the most important separation technique, since it is mandatory to achieve feasible solutions for the CPTP problem.

By recalling the GSEC inequality as presented in Equation \eqref{eq:gsec-constraints}, and the connected components as discussed in Section \ref{sec:integral-separation}, and in Algorithm \ref{algo:cc-dfs} we can pick $S \subseteq V_0 = \left\{ i \mid cc(i) = k  \right\}   \quad \forall k \in C, k > 0$.
Note that using major connected components, i.e. subtours, the set $S$ always satisfies $\SetSize*{S} \ge 2$.
Since we are dealing with integer CPTP solutions of the form $x^*_{ij},\ y^*_{i} \in \{0, 1\}$ it is easy to see that:

\begin{align}
	\sum_{(i, j) \in \delta(S)} x^*_{ij} = 0 \\
	y_i =  1 \quad \forall i \in S
\end{align}

which imply that the GSEC inequality $\sum_{(i, j) \in \delta(S)} x_{ij} \ge 2 y_i$ cannot be satisfied by any $i \in S$.
In a single integral separation iteration we can therefore separate:
\begin{equation}
	\sum^{n_c}_{k = 1} \SetSize*{ \Set*{ i \mid cc(i) = k \quad \forall i \in V } }
\end{equation}

violated GSECs inequality, which can be promptly reported to the MIP solver to reject the candidate integral solution.


\subsubsection{GSEC fractional separation}\label{sec:gsec-fractional-separation}

By recalling the GSEC inequality as presented in Equation \eqref{eq:gsec-constraints}, and the discussion about separating fractional $S \subseteq V_0$ in Section \ref{sec:fractional-separation}, it is easy to see that given a fractional solution instance of the form $0 \le x^*_{ij} \le 1,\ 0 \le y^*_{i} \le 1$ we have that:

\begin{equation}
	\sum_{(i, j) \in \delta(S)} x^*_{ij} = \maxflow(s, t)
\end{equation}

where the $\maxflow(s, t)$ denotes the maximum flow computed in the fractional separation of $S \subseteq V_0$.
Therefore, if $\SetSize*{S} \ge 2$, any $i \in S$ that violates

\begin{equation}
	\maxflow(s, t) \ge 2 y_i
\end{equation}

can be used to separate a violated GSEC inequality.
Recall that the number of sets $S \subseteq V_0$ in a fractional iteration is in the order of $\Theta(N^2)$, it is possible to separate $O(N^3)$ GSECs per separation.
We noticed that, generating and reporting all the violated GSECs inequalities across al fractional separation iterations led to a slow down of the MIP solver, which was flooded with weak GSEC inequalities.

Therefore, in our implementation we took a slightly different approach, by relaxing the conditions in which GSEC inequalities are reported to the MIP.
It is important to note that relaxing the conditions in which the GSEC fractional inequalities are reported, may lead to situations in which certain indispensible inequalities fall through without ever being handled in the fractional separation procedure.
But this situation is of a little importance to us, the remaining GSEC constraints which are not caught in the fractional separation, will eventually be handled by the complete integral separation procedure.

In our implementation a GSEC inequality is separated for $S \subseteq V_0,\ \SetSize*{S} \ge 2$ only if

\begin{equation}
	\maxflow(s, t) \ge 2 y_i - \varepsilon_{\mt{GSEC}}
\end{equation}

is violated.
The $\varepsilon_{\mt{GSEC}}$ is a constant which denotes the violation tolerance for the GSEC fractional separation.
In our implementation we picked $\varepsilon_{\mt{GSEC}} = 0.2$.
If the GSEC inequality violation does not surpass this tolerance, the GSEC inequality is not generated and reported to the MIP solver.
On top of that, to further reduce the number of generated GSECs, we report only the single most violated GSEC per set $S \subseteq V_0$ by using the customer $i \in V_0$ that maximizes the $\maxflow(s, t) - 2 y_i$ violation.

The complete pseudocode can be found in Algorithm \ref{algo:gsec-frac-sep}.

\begin{algorithm}
	\caption{An algorithm for separating GSEC integral inequalities for the CPTP}
	\label{algo:glm-integral-sep}
	\KwResult{$n_c$: number of subtours formed}
    \KwData{$cc[i] \in C$: connected component of $\forall i \in V$}
    \KwData{$x^*, y^* \in \{0, 1\}$: current optimal integral solution}
    \input{Content/Chapters/Snippets/gsec-integral-sep-pseudoalgo.tex}
\end{algorithm}



\begin{algorithm}
	\caption{An algorithm for separating GSEC fractional inequalities for the CPTP}
	\label{algo:gsec-frac-sep}
    \KwData{$\maxflow(s, t), F_1(s, t), F_2(s, t)$: maxflow and bipartitions induced from an arbitrary $s \ne t, s \in V, t \in V$ pair}
    \KwData{$x^*, y^* \in [0, 1]$: current optimal fractional solution}
    \input{Content/Chapters/Snippets/gsec-frac-sep-pseudoalgo.tex}
\end{algorithm}



\subsection{GLM separation}\label{sec:glm-separation}
In this section we describe the separation of the GLM inequalities, as they were defined in Equation \eqref{eq:glm-inequality}.
In our work we implemented both the integral and the fractional separation for this family of inequalities.
However, in this section we will explain only the fractional separation and we will omit the details about integral separation.
The integral separation follows naturally from adapting the ideas that will here after be presented in this section, and by employing a similar reasoning as was done in Section \ref{sec:gsec-integral-separation}, for the GSEC inequalities (i.e. using the connected components).

Let $F_1(s, t),\ F_2(s, t)$ be the bipartition induced in solving the min-cut problem as was presented in Section \ref{sec:fractional-separation}.
Again we showed that we can pick a valid $S \subseteq V_0$ in the following way

\begin{equation}
	S \subseteq V_0 =
	\begin{cases}
		F_1(s, t), & \texttt{if } 0 \notin F_1 \\
		F_2(s, t), & \texttt{otherwise}
	\end{cases}
\end{equation}

In case of the integral separation the same reasoning apply here, but instead of using the min-cut bipartition, we use the connected components array to find a valid $S \subseteq V_0$.

We need to count the number of vertices $i$ in $S$ to verify that indeed $\SetSize*{S} \ge 2$.
If $\SetSize*{S} < 2$, no GLM inequalities can be separated.
Otherwise a single GLM cut can be separated if the following inequality

\begin{equation}
	\begin{split}
		\ExprCptpFlowExitingWithWeight{S}{\Expr*{1 - 2 \frac{q_j}{Q}}} - 2 	\ExprCptpServedDemandWithWeight{S}{i}{\frac{q_i}{Q}} \ge - \varepsilon_{\mt{GLM}}
	\end{split}
\end{equation}

is violated.
The $\varepsilon_{\mt{GLM}}$ is a constant which denotes the violation tolerance for the GLM fractional separation.
In our implementation we picked $\varepsilon_{\mt{GLM}} = 0.05$.
We can separate $O(N^2)$ GLM cuts since the number of set $S \subseteq V_0$ is in the order of $\Theta(N^2)$ per fractional separation iteration.

The complete pseudocode for both the integral and fractional separation can be found in Algorithms \ref{algo:glm-integral-sep}, \ref{algo:glm-frac-sep} respectively.


\begin{algorithm}
	\caption{An algorithm for separating GLM integral inequalities for the CPTP}
	\label{algo:glm-integral-sep}
	\KwResult{$n_c$: number of subtours formed}
    \KwData{$cc[i] \in C$: connected component of $\forall i \in V$}
    \KwData{$x^*, y^* \in \{0, 1\}$: current optimal integral solution}
    \input{Content/Chapters/Snippets/glm-integral-sep-pseudoalgo.tex}
\end{algorithm}


\begin{algorithm}
	\caption{An algorithm for separating GLM fractional inequalities for the CPTP}
	\label{algo:glm-frac-sep}
    \KwData{$\maxflow(s, t), F_1(s, t), F_2(s, t)$: maxflow and bipartitions induced from an arbitrary $s \ne t, s \in V, t \in V$ pair}
    \KwData{$x^*, y^* \in [0, 1]$: current optimal fractional solution}
    \input{Content/Chapters/Snippets/glm-frac-sep-pseudoalgo.tex}
\end{algorithm}



\subsection{RCI separation}\label{sec:rci-separation}
In this section we describe the separation of the RCI inequalities, as they were defined in Equation \eqref{eq:rci-inequality}.
In our work we implemented both the integral and the fractional separation for this family of inequalities.
However, we will omit the detail of the integral separation in this section, since they follow naturally from ideas explained in previous sections.

The fractional separation of RCI inequalities is not any different from the separation of the GLM fractional inequalities presented in Section \ref{sec:glm-separation}.
The only difference is that the set $S \subseteq V_0$, does not need to satisfy $\SetSize*{S} \ge 2$.

Therefore, a set $\SetSize*{S} \subseteq V_0$ can separate a single RCI cut if the following inequality

\begin{equation}
	\begin{split}
		\ExprCptpFlowExiting{S} -2 \ExprCptpServedDemandWithWeight{S}{i}{\frac{q_i}{\ExprQrS}}    \ge   2 \left( \ceil*{ \frac{q(S)}{Q}} - \frac{q(S)}{Q_{\mathrm{R}}(S)} \right) - \varepsilon_{\mt{RCI}}
	\end{split}
\end{equation}

is violated.
The $\varepsilon_{\mt{RCI}}$ is a constant which denotes the violation tolerance for the RCI fractional separation.
In our implementation we picked $\varepsilon_{\mt{RCI}} = 0.05$.
We can separate $O(N^2)$ RCI cuts since the number of set $S \subseteq V_0$ is in the order of $\Theta(N^2)$ per fractional separation iteration.

The complete pseudocode for both the integral and fractional separation can be found in Algorithms \ref{algo:rci-integral-sep}, \ref{algo:rci-frac-sep} respectively.


\begin{algorithm}
	\caption{An algorithm for separating RCI integral inequalities for the CPTP}
	\label{algo:rci-integral-sep}
	\KwResult{$n_c$: number of subtours formed}
    \KwData{$cc[i] \in C$: connected component of $\forall i \in V$}
    \KwData{$x^*, y^* \in \{0, 1\}$: current optimal integral solution}
    \input{Content/Chapters/Snippets/rci-integral-sep-pseudoalgo.tex}
\end{algorithm}


\begin{algorithm}
	\caption{An algorithm for separating RCI fractional inequalities for the CPTP}
	\label{algo:rci-frac-sep}
    \KwData{$\maxflow(s, t), F_1(s, t), F_2(s, t)$: maxflow and bipartitions induced from an arbitrary $s \ne t, s \in V, t \in V$ pair}
    \KwData{$x^*, y^* \in [0, 1]$: current optimal fractional solution}
    \input{Content/Chapters/Snippets/rci-frac-sep-pseudoalgo.tex}
\end{algorithm}
