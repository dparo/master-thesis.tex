\chapter{Results}
\label{sec:results}

\section{CVRP Benchmark Instances}
\label{sec:results-benchmark-instances}
To satisfactorily measure the competitiveness of our branch-an-cut pricer,
the usage of several CVRP benchmark instances is a mandatory necessity.
The \urlref{http://vrp.atd-lab.inf.puc-rio.br/index.php/en/}{CVRPLIB website}
is an online database for the vehicle routing problem,
which contains, among other things,
many freely downloadable CVRP test instances.
This very useful resource can be used
as a main point of reference by all the interested individuals.
It contains interactive plots of an exhaustive number of routing problems instances,
along with the best known/optimal solution found by the best scholars over the years.
Each CVRP test instance is stored in a file which filename follows a specific template of the form:

\begin{center}
	\begin{LVerbatim}
		<F>-n<N>-k<K>.vrp
	\end{LVerbatim}
\end{center}

where \texttt{.vrp} is the file extension,
\texttt{<N>} is the number of customers in the instance,
\texttt{<K>} is the number of (maximum or exact) available vehicles
and finally \texttt{<F>} denotes the set instance family.
\texttt{<F>} is a single letter which uniquely identifies the instance
set along with the authors who published such set.
As an example \texttt{P-n40-k5.vrp} denotes a test instance composed
of $40$ customers and $5$ vehicles.
The \texttt{P} in the name, indicates the instance set family, which in this
case it was published in \textcite{augerat1995}.

The contents of each CVRP instance file follows the \texttt{TSPLIB95} file format \parencite{reinelt1995}.
As it became usual for the TSP in \textcite{reinelt1991},
distances between pairs of nodes
is computed through a 2D Euclidean distance function
rounded to the nearest integer.
Rounding is done to make the optimal values more stable, so that the comparison between different contributions is achievable.
However, rounding introduces problems in comparing heuristic contributions, see \textcite{uchoa2017} for more details.

\medskip

To evaluate the performance of our pricer we used some of the most historic,
and commonly known,
CVRP instances:
set A, B, P \parencite{augerat1995}, set E \parencite{christofides1969},
set F \parencite{fisher1994}
and finally set M \parencite{christofides1979}.
The reader who's interested in knowing how such instances were obtained in the first
place, can refer to either the CVRPLIB website or to the work of \textcite{uchoa2017}.

\medskip
\mytodo{Put all the employed CVRP instances in tables. Similar as it is done in \cite{uchoa2017}}

\section{\bapcod}
\label{sec:results-bapcod}

\textit{\bapcod}\ \parencite{sadykov2021} is a software package
developed in France at the Bordeaux University and Bordeaux Research Center,
which implements a sophisticated column generation approach
embedded inside a generic and modern branch-price-and-cut (BPC) algorithm.
\bapcod\ takes as input a compact mixed integer programming model,
and solves it by applying a Dantzig-Wolfe reformulation \parencite{dantzig1960}.
The reformulation is automatically applied by the solver
and a default generic pricer relying on
the usage of a MIP solver is employed in the column generation procedure.
An automatic dual price smoothing stabilization, discussed in \textcite{pessoa2018automation},
is applied by \bapcod\ to improve the convergence speed of the column generation.
\bapcod, being generic in nature,
supports user developed extensions.
These extensions can supply the BPC framework with either
custom defined cutting-planes (robust or non), custom branching decisions (robust or non)
or even ad-hoc pricer implementations.

The \textit{VRPSolver} extension \parencite{pessoa2020a}, is
a \bapcod\ extension distributed by the same authors.
This extension includes an
advanced implementation of a bidirectional dynamic programming labeling algorithm
\parencite{sadykov2021a} for solving the pricing problem.
The included labeling algorithm
can be both used as an exact pricer or as a heuristic one.
Precisely, it contains two successively lighter heuristic implementations, see \textcite{sadykov2021a} for more details.
The labeling algorithm makes use of a generalized ng-sets definition \parencite{baldacci2011}
defined through packing and elementarity sets as presented in \textcite{pessoa2020a}.
The ng-sets are dynamically augmented \parencite{roberti2014}
when the solution obtained after the column generation convergence
is fractional,
see \textcite{pessoa2020a} for more details.
The VRPSolver extension, also,
contains the implementation of some
specific cutting-planes and branching decisions
tailored at efficiently solving routing-like problems
(or problems that exhibit similar structures)
such as the CVRP, VRPTW and also others (see \cite{pessoa2020a}).
The VRPSolver extension was also successfully applied
to solve Bin Packing Problems in \textcite{pessoa2020}.

\medskip

\bapcod\ along with its VRPSolver extension are currently the leading state-of-the-art
technologies for solving vehicle routing problems \parencite{pessoa2020a}.
The \bapcod\ source code can be downloaded for free, for academic purposes only,
by issuing a form request at this url: \url{https://bapcod.math.u-bordeaux.fr/}.
The VRPSolver extension, instead, is available for academic use only in compiled form,
and must be explicitly requested by email by contacting one of the
original authors: \url{mailto:ruslan.sadykov@inria.fr}.
Instructions to build, setup and employ \bapcod\ and its VRPSolver extension
can be found in the official technical report presented in \textcite{sadykov2021}.

Refer to \textcite{sadykov2019b},
for a complete technical discussion on the common ingredients of modern and advanced BPC frameworks.

\section{Evaluation Setup}
\label{sec:results-evaluation-setup}

\mytodo{This section is written like shit. Please rephrase it in sane English}

When faced with the option of developing our branch-and-cut pricer,
we had to choose between two main choices:
(i) developing our pricer in tight integration with the BPC framework,
by coding it as a \bapcod\ plugin,
or (ii) developing the pricer in a standalone executable,
separate from the BPC framework.

To keep things as simple as possible we opted for the latter choice.
This choice allowed us to gain more freedom in the implementation
such as: choosing any language that we liked (C),
achieving isolated testing,
and allowing us to use any external libraries
that we wished without risking in linker conflicts.

Despite in our decision, we have valued simplicity above all,
it has to be noted that our choice leads a very big downside that has to be acknowledged.

To keep things as simple as possible, we've decided to implement our
pricer in a standalone separate program instead of developing it as a \bapcod\ extension.
While this approach was convenient, it has to be noted that the performance comparison is not
completely fair, since by running it in a separate process, better dual bound improvements
don't lead to less pricing iterations.
The performance comparison is performed on a per pricing iteration.
Our pricer, since it works with elementary paths, may require less number of iterations
to prove no-more reduced cost routes exist, while a relaxed-elementarity SPPRC solver
might require more iterations.

\section{Evaluation Process}
\label{sec:results-evaluation-process}

We've employed \bapcod\ version 0.66 (released in November 2021) and the \texttt{libRCSP v0.5.12}.
The latter library contains the VRPSolver extension implementation.
The objective is to use \bapcod\ to solve a CVRP instance while simultaneously
measuring the running time of the labeling algorithm for each pricing invocation.

\medskip

By following the \bapcod\ technical document \parencite{sadykov2021},
we've re-adapted one of the VRPTW example (included in the distribution),
to model a Capacitated Vehicle Routing Problem.
The model that we've implemented follows two-index arc flow model
discussed \cref{eq:two-index-flow-obj-func,eq:two-index-flow-two-edges-incident-per-customer,eq:two-index-flow-two-k-edges-incident-in-the-depot-node,eq:two-index-flow-ccc,eq:two-index-flow-x-mip-var-bounds-depot,eq:two-index-flow-x-mip-var-bounds}
but excluding the Rounded Capacity Constraints (RCC) of \cref{eq:two-index-flow-ccc}.

In order to use the VRPSolver labeling algorithm, it is necessary
to define Resource Constrained Shortest Path (RCSP) sub-problem.
The RCSP sub-problem is formulated on a complete directed network by
linking the RCSP modeling variables to the original CVRP formulations.
The RCSP sub-problem requires for the correct definition of the source and sink
vertices.
The RCSP sub-problem also requires for the definition the so-called packing and elementarity
sets for each customer (see \cite{pessoa2020a} for more details).
The correct definition of these generalized sets is mandatory to allow for specific
components of the VRPSolver extension to work correctly (ng-sets, RCC separation, etc).
A separate packing set and a separate elementarity set is dedicated for each customer.
The VRPSolver extension requires also for the explicit definition of an additional
distance matrix encoding the distance between pairs of elementarity sets.
The ng-sets are computed automatically by employing the elementarity sets
according to a distance matrix which also needs to be set by the user
to the distance between customers.

Due to implementation details, the RCSP sub-problem requires
the definition of the amount of resource consumption for each arc of the network.
But in CVRP the resource consumption is defined per customer.
Therefore, as suggested in \textcite{pessoa2020a}, we can define the resource consumption
on the arcs as $q_{ij} = \frac{q_{i} + q_{j}}{2} \quad \forall i, j \in V$.
This definition is correct and it leads to a symmetric resource consumption ($q_{ij} = q_{ji}$),
which have the benefit of speeding the efficiency at pricing,
by eliminating the need of performing backward labelling.

\medskip

We've setup \bapcod\ in a such a way that the resolution process stops at the root
node of the branch-and-bound tree.
Therefore, cutting-planes and branching were disabled in our experiments.
Although, notice that branching on arcs and RCC inequalities may be
enabled without affecting our branch-and-cut pricer, but non-robust
inequalities are not supported by our pricer.
In order to obtain a more fair comparison, we've setup \bapcod\ as to prioritize
the ng-sets augmentation whenever possible as to achieve a dual bound as close
as possible to the elementarity bound, and on top of that,
we've setup the VRPSolver extension pricer to produce a single column
per column generation iterations, since our pricer is not able to achieve
such a condition.
We've implemented a custom functor (i.e. a glorified callback) to solve the pricing problem.
Our functor does the following.
First for each exact pricing iteration it dumps the problem and the corresponding dual variables
in a separate file for each iteration.
It forwards the pricing problem to a dynamic programming labeling algorithm
implemented in the VRPSolver pricing functor.
At each invocation of the labeling algorithm, our functor extracts timing informations
which it reportedly dumps so that timing comparisons against our pricer can be achieved later.

% \section{Model}
%
% \mytodo{Write the BapCod model here}
%
% \mytodo{Point out that general branching and general cuts are disabled in BapCod}
%
% \mytodo{Note that specific ESPPRC type of non-robust branching\&cuts are disabled in the BapCod model}

\subsection{Dual values extraction}

\mytodo{Talk about how we extract the dual values from the BapCod model reduced cost variables}

\subsection{Performance profiles}
\label{sec:results-performance-profiles}

\textit{Performance profiles} are a plot representation used to benchmark optimization software,
first presented in \textcite{dolan2002}.
Performance profiles are simple to interpret and less subject to personal interpretation.
In short, performance profiles plot the cumulative distribution function with respect to a performance metric.
We test $H$ algorithms by running them on $M$ problem instances.
In the X-axis, we plot the performance metric ratio with respect to a baseline.
The baseline is computed as the best performance achieved by all the algorithms under analysis.
The Y-axis instead shows the probability of being within an X ratio from the baseline.

\medskip

We've extensively employed performance profiles to compare the competitiveness of
our proposed branch-and-cut based pricer
against the RCSP dynamic programming algorithm used by \bapcod\ \parencite{pessoa2020a}.

\begin{comment}
In this thesis, we will use performance profiles extensively to measure each solver by exploiting two performance metrics: \textbf{Time metric}, \textbf{Cost metric}.

A \textbf{Time performance profile} will tell us which resolution method is the fastest in terms of runtime.
A \textbf{Cost performance profile}, instead, will show us the cost ratio of the best upper bound obtained from each resolution method.
The ground truth optimal, as extracted from the dataset, is used instead as the cost baseline.
\end{comment}

\section{Empirical Results}
\label{sec:results-empirical-results}

\mytodo{Describe operating system, processor speed, etc}

\mytodo{Spam this section with performance profiles}

\section{Discussion}
\label{sec:results-discussion}

\mytodo{Complete this section after populating the Empirical Results with the appropriate perfprofiles}

\begin{comment}
\mytodo{Include the F-n135 grep result to talk about the difficulty of this instance and related ones}
\end{comment}
