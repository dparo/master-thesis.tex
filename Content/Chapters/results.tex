\chapter{Results}
\label{sec:results}

\section{\bapcod}
\label{sec:results-bapcod}

\textit{\bapcod}\ \parencite{sadykov2021} is a software package
developed in France at the Bordeaux University and Bordeaux Research Center,
which implements a modern generic branch-price-and-cut (BPC) algorithm
and a column generation procedure.
Refer to \textcite{sadykov2019b}, for a complete discussion to modern BPC frameworks.
\bapcod\ takes as input a compact mixed integer programming model,
and solves it by applying a Dantzig-Wolfe reformulation \parencite{dantzig1960}.
The reformulation is automatically applied by the solver
and a default generic pricer relying on
the usage of a MIP solver is employed in the column generation procedure.
An automatic dual price smoothing stabilization, discussed in \textcite{pessoa2018automation},
is applied by \bapcod\ to improve the convergence speed of the column generation.
\bapcod, being generic in nature,
supports user developed extensions.
These extensions can supply the BPC framework with either
custom defined cutting-planes (robust or non), custom branching decisions (robust or non),
or even ad-hoc pricer implementations.

The \textit{VRPSolver} extension \parencite{pessoa2020a}, is
a \bapcod\ extension distributed by the same authors.
This extension includes an
an advance implementation of a bidrectional dynamic programming labeling algorithm
\parencite{sadykov2021a} for solving the pricing problem.
The VRPSolver extension also implements
some cutting cutting-planes and branching decisions
tailored at efficiently solving routing-like problems
(or problems that exhibit similar structures)
such as the CVRP, VRPTW and also others (see \cite{pessoa2020a}).
The VRPSolver extension was also successfully applied
to solve Bin Packing Problems in \textcite{pessoa2020}.

\bapcod\ along with its VRPSolver are currently the leading state-of-the-art
technology for solving vehicle routing problems \parencite{pessoa2020a}.
The \bapcod\ source code can be downloaded for free, for academic purposes only,
by issuing a form request at this url: \url{https://bapcod.math.u-bordeaux.fr/}.
The VRPSolver extension, instead, is available for academic use only in compiled form,
and must be explicitly requested by email by contacting one of the
original authors: \url{mailto:ruslan.sadykov@inria.fr}.
Instructions to build, setup and employ \bapcod\ and its VRPSolver extension
can be found in the official technical report presented in \textcite{sadykov2021}.

\section{CVRP Benchmark Instances}
\label{sec:results-benchmark-instances}

\mytodo{Introduce the original benchmark used and their naming convention, and filename convention <F>-n<X>-k<Y>}

\mytodo{Talk about how benchmark instances are obtained}

\mytodo{Say that they follow the TSPLIB95 file format}

\mytodo{Say that the distances are rounded. Refer to \cite{uchoa2017}, which contains a small explanation why this is done}

\begin{comment}
\cite{uchoa2017}
THE CVRPLIB website
The typical instance repository of today is a web page that allows downloading the instance
files and includes additional textual information, like file format description, instance
source, best known/optimal solution values, etc. The CVRLIB web page, where the new
instances (and all the previous CVRP instances described in Section 2) are available
(http://vrp.galgos.inf.puc-rio.br/index.php/en/), is more sophisticated:
\end{comment}

\mytodo{Put all the instances used in tables as is done in \cite{uchoa2017}}

\section{Evaluation Method}
\label{sec:results-evaluation-method}

When faced with the option of developing our branch-and-cut pricer,
we had to choose between two main choices:
(i) developing our pricer in tight integration with the BPC framework,
by coding it as a \bapcod\ plugin,
or (ii) developing the pricer in a standalone executable,
separate from the BPC framework.

To keep things as simple as possible we opted for the latter choice.
This choice allowed us to gain more freedom in the implementation
such as: choosing any language that we liked (C),
achieving isolated testing,
and allowing us to use any external libraries
that we wished without risking in linker conflicts.

Despite in our decision, we have valued simplicity above all,
it has to be noted that our choice leads a very big downside that has to be acknowledged.

To keep things as simple as possible, we've decided to implement our
pricer in a standalone separate program instead of developing it as a \bapcod\ extension.
While this approach was convenient, it has to be noted that the performance comparison is not
completely fair, since by running it in a separate process, better dual bound improvements
don't lead to less pricing iterations.
The performance comparison is performed on a per pricing iteration.
Our pricer, since it works with elementary paths, may require less number of iterations
to prove no-more reduced cost routes exist, while a relaxed-elementarity SPPRC solver
might require more iterations.

\bapcod\ version 0.66 (released in November 2021) and the libRCSP version 0.5.12,
containing the VRPSolver extension implementation were used.

By following the \bapcod\ API, extensively documented in \textcite{sadykov2021},
and by re-adapting one of the VRPTW example distributed with \bapcod\ itself,
we've implemented the CVRP two-index arc flow model
of \cref{eq:two-index-flow-obj-func,eq:two-index-flow-two-edges-incident-per-customer,eq:two-index-flow-two-k-edges-incident-in-the-depot-node,eq:two-index-flow-ccc,eq:two-index-flow-x-mip-var-bounds-depot,eq:two-index-flow-x-mip-var-bounds},
but excluding the Capacity Cut Constraints (CCC) of \cref{eq:two-index-flow-ccc}.

We've setup \bapcod\ in a such a way that the resolution process stops at the root
node of the branch-and-bound tree.
Therefore, cutting-planes and branching were disabled in our experiments.
Although, notice that branching on arcs and RCC inequalities may be
enabled without affecting our branch-and-cut pricer, but non-robust
inequalities are not supported by our pricer.
In order to obtain a more fair comparison, we've setup \bapcod\ as to prioritize
the ng-sets augmentation whenever possible as to achieve a dual bound as close
as possible to the elementarity bound, and on top of that,
we've setup the VRPSolver extension pricer to produce a single column
per column generation iterations, since our pricer is not able to achieve
such a condition.
We've implemented a custom functor (i.e. a glorified callback) to solve the pricing problem.
Our functor does the following.
First for each exact pricing iteration it dumps the problem and the corresponding dual variables
in a separate file for each iteration.
It forwards the pricing problem to the dynamic programming labeling algorithm
implemented in the VRPSolver pricing functor.
At each invocation of the labeling algorithm, our functor extracts timing informations
which it reportedly dumps so that timing comparisons against our pricer can be achieved later.

\section{Performance profiles}
\label{sec:results-performance-profiles}

\textit{Performance profiles} are a plot representation used to benchmark optimization software,
first presented in \textcite{dolan2002}.
Performance profiles are simple to interpret and less subject to personal interpretation.
In short, performance profiles plot the cumulative distribution function with respect to a performance metric.
We test $H$ algorithms by running them on $M$ problem instances.
In the X-axis, we plot the performance metric ratio with respect to a baseline.
The baseline is computed as the best performance achieved by all the algorithms under analysis.
The Y-axis instead shows the probability of being within an X ratio from the baseline.

\medskip

We've extensively employed performance profiles to compare the competitiveness of
our proposed branch-and-cut based pricer
against the RCSP dynamic programming algorithm used by \bapcod\ \parencite{pessoa2020a}.

\begin{comment}
In this thesis, we will use performance profiles extensively to measure each solver by exploiting two performance metrics: \textbf{Time metric}, \textbf{Cost metric}.

A \textbf{Time performance profile} will tell us which resolution method is the fastest in terms of runtime.
A \textbf{Cost performance profile}, instead, will show us the cost ratio of the best upper bound obtained from each resolution method.
The ground truth optimal, as extracted from the dataset, is used instead as the cost baseline.
\end{comment}

\section{Empirical Results}
\label{sec:results-empirical-results}
\mytodo{Spam this section with performance profiles}

\section{Discussion}
\label{sec:results-discussion}

\mytodo{Include the F-n135 grep result to talk about the difficulty of this instance and related ones}

We noticed many branch-and-bound nodes being generated,
suggesting that a smarter and more effective bounding technique to
generate an effective initial dual bound could speed up the convergence
of the MIP solver by reducing the number of branching occurrences.

Heuristic algorithm to solve maxflow???
