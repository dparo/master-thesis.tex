\chapter{Results}
\label{sec:results}

\section{\bapcod}
\label{sec:results-bapcod}

\textit{\bapcod}\ \parencite{sadykov2021} is a software package
developed in France at the Bordeaux University and Bordeaux Research Center,
which implements a sophisticated column generation approach
embedded inside a generic and modern branch-price-and-cut (BPC) algorithm.
\bapcod\ takes as input a compact mixed integer programming model,
and solves it by applying a Dantzig-Wolfe reformulation \parencite{dantzig1960}.
The reformulation is automatically applied by the solver
and a default generic pricer relying on
the usage of a MIP solver is employed in the column generation procedure.
An automatic dual price smoothing stabilization, discussed in \textcite{pessoa2018automation},
is applied by \bapcod\ to improve the convergence speed of the column generation.
\bapcod, being generic in nature,
supports user developed extensions.
These extensions can supply the BPC framework with either
custom defined cutting-planes (robust or non), custom branching decisions (robust or non)
or even ad-hoc pricer implementations.

The \textit{VRPSolver} extension \parencite{pessoa2020a}, is
a \bapcod\ extension distributed by the same authors.
This extension includes an
advanced implementation of a bidirectional dynamic programming labeling algorithm
\parencite{sadykov2021a} for solving the pricing problem.
The included labeling algorithm
can be both used as an exact pricer or as a heuristic one.
Precisely, it contains two successively lighter heuristic implementations, see \textcite{sadykov2021a} for more details.
The labeling algorithm makes use of a generalized ng-sets definition \parencite{baldacci2011}
defined through packing and elementarity sets as presented in \textcite{pessoa2020a}.
The ng-sets are dynamically augmented \parencite{roberti2014}
after the column generation convergence only if the MP contains a fractional solution,
see \textcite{pessoa2020a} for more details.
The VRPSolver extension also implements
some cutting cutting-planes and branching decisions
tailored at efficiently solving routing-like problems
(or problems that exhibit similar structures)
such as the CVRP, VRPTW and also others (see \cite{pessoa2020a}).
The VRPSolver extension was also successfully applied
to solve Bin Packing Problems in \textcite{pessoa2020}.

\bapcod\ along with its VRPSolver are currently the leading state-of-the-art
technology for solving vehicle routing problems \parencite{pessoa2020a}.
The \bapcod\ source code can be downloaded for free, for academic purposes only,
by issuing a form request at this url: \url{https://bapcod.math.u-bordeaux.fr/}.
The VRPSolver extension, instead, is available for academic use only in compiled form,
and must be explicitly requested by email by contacting one of the
original authors: \url{mailto:ruslan.sadykov@inria.fr}.
Instructions to build, setup and employ \bapcod\ and its VRPSolver extension
can be found in the official technical report presented in \textcite{sadykov2021}.

Refer to \textcite{sadykov2019b},
for a complete technical discussion on the ingredients of modern BPC frameworks.


\section{CVRP Benchmark Instances}
\label{sec:results-benchmark-instances}

To assess the competitiveness of our branch-and-cut pricer, we employed several
CVRP test instances.
Many test instances are freely available on the \urlref{http://vrp.atd-lab.inf.puc-rio.br/index.php/en/}{CVRPLIB website}.
The \textit{CVRPLIB website} is a fantastic online resource for VRP practitioners.
It contains interactive plots of many routing problems instances,
along with the exact solution found by the operations research community over the years.
Each CVRP test instance is stored in a file, which filename follows a specific template of the form:

\begin{center}
	\begin{LVerbatim}
		<F>-n<N>-k<K>.vrp
	\end{LVerbatim}
\end{center}

where \texttt{.vrp} is the file extension,
\texttt{<N>} is the number of customers in the instance,
\texttt{<K>} is the number of (maximum or exact) available vehicles
and finally \texttt{<F>} denotes the set instance family.
\texttt{<F>} is a single letter which uniquely identifies the instance
set along with the authors who published such set.
As an example: \texttt{P-n40-k5.vrp}, where \texttt{P} is the
instance set family (published in \textcite{augerat1995}).

Each CVRP instance follows the \texttt{TSPLIB95} file format \parencite{reinelt1995}.
As it became usual for the TSP in \textcite{reinelt1991},
distances between pairs of nodes
is computed by rounding to the nearest integer the conventional 2D Euclidean distance function.
Rounding is performed to make the optimal values found by different contributions more stable for comparison.
Yet rounding induces problem in comparing heuristic approaches contributions, see \textcite{uchoa2017} for more details.

\mytodo{Introduce the original benchmark used and their naming convention, and filename convention <F>-n<X>-k<Y>}

\mytodo{Talk about how benchmark instances are obtained}

\mytodo{Say that they follow the TSPLIB95 file format}

\mytodo{Say that the distances are rounded. Refer to \cite{uchoa2017}, which contains a small explanation why this is done}

\mytodo{Put all the instances used in tables as is done in \cite{uchoa2017}}

\begin{comment}

\cite{uchoa2017}
THE CVRPLIB website
The typical instance repository of today is a web page that allows downloading the instance
files and includes additional textual information, like file format description, instance
source, best known/optimal solution values, etc. The CVRLIB web page, where the new
instances (and all the previous CVRP instances described in Section 2) are available
(http://vrp.galgos.inf.puc-rio.br/index.php/en/), is more sophisticated:
\end{comment}


\section{Evaluation Setup}
\label{sec:results-evaluation-setup}

When faced with the option of developing our branch-and-cut pricer,
we had to choose between two main choices:
(i) developing our pricer in tight integration with the BPC framework,
by coding it as a \bapcod\ plugin,
or (ii) developing the pricer in a standalone executable,
separate from the BPC framework.


To keep things as simple as possible we opted for the latter choice.
This choice allowed us to gain more freedom in the implementation
such as: choosing any language that we liked (C),
achieving isolated testing,
and allowing us to use any external libraries
that we wished without risking in linker conflicts.

Despite in our decision, we have valued simplicity above all,
it has to be noted that our choice leads a very big downside that has to be acknowledged.


To keep things as simple as possible, we've decided to implement our
pricer in a standalone separate program instead of developing it as a \bapcod\ extension.
While this approach was convenient, it has to be noted that the performance comparison is not
completely fair, since by running it in a separate process, better dual bound improvements
don't lead to less pricing iterations.
The performance comparison is performed on a per pricing iteration.
Our pricer, since it works with elementary paths, may require less number of iterations
to prove no-more reduced cost routes exist, while a relaxed-elementarity SPPRC solver
might require more iterations.



\section{Evaluation Method}
\label{sec:results-evaluation-method}


\bapcod\ version 0.66 (released in November 2021) and the libRCSP version 0.5.12,
containing the VRPSolver extension implementation were used.

By following the \bapcod\ API, extensively documented in \textcite{sadykov2021},
and by re-adapting one of the VRPTW example distributed with \bapcod\ itself,
we've implemented the CVRP two-index arc flow model
of \cref{eq:two-index-flow-obj-func,eq:two-index-flow-two-edges-incident-per-customer,eq:two-index-flow-two-k-edges-incident-in-the-depot-node,eq:two-index-flow-ccc,eq:two-index-flow-x-mip-var-bounds-depot,eq:two-index-flow-x-mip-var-bounds},
but excluding the Capacity Cut Constraints (CCC) of \cref{eq:two-index-flow-ccc}.
In order to solve the CVRP through \bapcod, an RCSP sub-problem must also be defined.
The RCSP sub-problem is formulated on a complete directed network by
binding the RCSP modeling variables to the original CVRP formulations.
For each vertex of the RCSP network we've also defined correctly the source
and sink vertices and we've also defined packing and elementarity sets
for each customer.
The correct definition of these sets is mandatory to allow for specific
components of the VRPSolver extension to work correctly (ng-sets, RCC separation, etc).
The ng-sets are computed automatically by employing the elementarity sets
according to a distance matrix which also needs to be set by the user
to the distance between customers.
Due to implementation details, the RCSP sub-problem requires
the definition of the amount of resource consumption for each arc of the network.
But in CVRP the resource consumption is defined per customer.
Therefore, as suggested in \textcite{pessoa2020a}, we can define the resource consumption
on the arcs as $q_{ij} = \frac{q_{i} + q_{j}}{2} \quad \forall i, j \in V$.
This definition is correct and it leads to a symmetric resource consumption ($q_{ij} = q_{ji}$),
which have the benefit of speeding the efficiency at pricing,
by eliminating the need of performing backward labelling.

We've setup \bapcod\ in a such a way that the resolution process stops at the root
node of the branch-and-bound tree.
Therefore, cutting-planes and branching were disabled in our experiments.
Although, notice that branching on arcs and RCC inequalities may be
enabled without affecting our branch-and-cut pricer, but non-robust
inequalities are not supported by our pricer.
In order to obtain a more fair comparison, we've setup \bapcod\ as to prioritize
the ng-sets augmentation whenever possible as to achieve a dual bound as close
as possible to the elementarity bound, and on top of that,
we've setup the VRPSolver extension pricer to produce a single column
per column generation iterations, since our pricer is not able to achieve
such a condition.
We've implemented a custom functor (i.e. a glorified callback) to solve the pricing problem.
Our functor does the following.
First for each exact pricing iteration it dumps the problem and the corresponding dual variables
in a separate file for each iteration.
It forwards the pricing problem to a dynamic programming labeling algorithm
implemented in the VRPSolver pricing functor.
At each invocation of the labeling algorithm, our functor extracts timing informations
which it reportedly dumps so that timing comparisons against our pricer can be achieved later.

\subsection{Performance profiles}
\label{sec:results-performance-profiles}

\textit{Performance profiles} are a plot representation used to benchmark optimization software,
first presented in \textcite{dolan2002}.
Performance profiles are simple to interpret and less subject to personal interpretation.
In short, performance profiles plot the cumulative distribution function with respect to a performance metric.
We test $H$ algorithms by running them on $M$ problem instances.
In the X-axis, we plot the performance metric ratio with respect to a baseline.
The baseline is computed as the best performance achieved by all the algorithms under analysis.
The Y-axis instead shows the probability of being within an X ratio from the baseline.

\medskip

We've extensively employed performance profiles to compare the competitiveness of
our proposed branch-and-cut based pricer
against the RCSP dynamic programming algorithm used by \bapcod\ \parencite{pessoa2020a}.

\begin{comment}
In this thesis, we will use performance profiles extensively to measure each solver by exploiting two performance metrics: \textbf{Time metric}, \textbf{Cost metric}.

A \textbf{Time performance profile} will tell us which resolution method is the fastest in terms of runtime.
A \textbf{Cost performance profile}, instead, will show us the cost ratio of the best upper bound obtained from each resolution method.
The ground truth optimal, as extracted from the dataset, is used instead as the cost baseline.
\end{comment}

\section{Empirical Results}
\label{sec:results-empirical-results}
\mytodo{Spam this section with performance profiles}

\section{Discussion}
\label{sec:results-discussion}

\mytodo{Include the F-n135 grep result to talk about the difficulty of this instance and related ones}

We noticed many branch-and-bound nodes being generated,
suggesting that a smarter and more effective bounding technique to
generate an effective initial dual bound could speed up the convergence
of the MIP solver by reducing the number of branching occurrences.

Heuristic algorithm to solve maxflow???
