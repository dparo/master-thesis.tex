\chapter{Implementation}

\mytodo{Introduce the project, say it is written in C, point to the github repo url, etc...}

\section{Introduction to CPLEX}

\mytodo{Explain what is CPLEX, academic license, url where it can be downloaded etc}


\section{Full static model}

\begin{align}
	\min_{x,y} \quad z(x, y) & =  \sum_{i \in V} \sum_{\substack{j \in V                                                                                                   \\ j \ge i + 1}} d_{ij} x_{ij} - \sum_{i \in V} p_i y_i \label{eq:obj-function}\\
	                         & y_0 = 1                                           & \label{eq:full-static-model-depot-part-of-tour-constraint}                              \\
	                         & \sum_{j \in \delta(i)}       x_{ij}    = 2        & \quad \forall i \in V         \label{eq:full-static-model-flow-conservation-constraint} \\
	                         & B \le   \sum_{i \in V} q_i y_i   \le Q            & \label{eq:full-static-model-resource-upper-bound-constraint}                            \\
	                         & x_{ij}                   \in \lbrace 0, 1 \rbrace & \quad \forall (i, j) \in E               \label{eq:full-static-model-x-mip-var-bounds}  \\
	                         & y_{i}                    \in \lbrace 0, 1 \rbrace & \quad \forall i \in V,\ i \ge 1          \label{eq:full-static-model-y-mip-var-bounds}
\end{align}

which follows closely the full IP formulation presented in \eqref{eq:obj-function} without the GSECs.
We also added a non strictly necessary upper bound on the served demand, which details were already discussed earlier in Section \ref{sec:demand-lower-bound}.

\section{Cutoff values}


\subsection{Upper cuttoff value}
Since we're interested in solving the CPTP in the context of pricing for the CVRP, we're interested only in valid tours achieving a strictly negative objective value.
Therefore we can specify an upper cutoff for objective function $z(x, y)$:

\begin{equation}
	z(x, y) \le 0 - \epsilon_{\mt{ct}}
\end{equation}

where $\epsilon_{\mt{ct}} \in \R$ is the upper cutoff tolerance, in our implementation we picked $\epsilon_{\mt{ct}} = 10^{-6}$, which is the default used in BapCod.

The upper cutoff value can improve the linear relaxation and reduce the number of branch and bound nodes that need to be explored, especially when the MIP solver cannot infer any good starting primal solution.

\subsection{Lower cutoff value}
A good lower cutoff value on the objective function can improve the linear relaxation, and reduce the number of branch and bounds nodes that need to be explored.
When combined with an upper cutoff value, and a good set of warm start solutions it can help to start the solution process with an already relatively closed gap.

A lower cutoff value can be obtained by any feasible dual solution.
For example we could use the method briefly described in Section \ref{sec:cptp-simple-dual-formulation} to obtain a good feasible dual solution.
At the time of writing of this draft report (late Jan, firsts Feb 2022) the method described in Section \ref{sec:cptp-simple-dual-formulation} was not extensively explored.

Instead we opted for a much simpler dual bound:

\begin{equation}
	z(x, y) \ge - \sum_{i \in V} p_i
\end{equation}

which is a trivial and weak bound, and in pretty much all cases, is easily beaten by a better alternative computed from the preprocessing stage of a standard MIP solver.

\section{Warm start}

\section{Separation techniques}

Inequality separation is a problem which consists in finding strong valid violated inequalities so that such inequalities can be embedded inside a Branch\&Cut framework.
Integral inequality separation is concerned in determining violated inequalities for the original IP model.
Integral inequalities separation is usually much easier to perform, and can be seen as a procedure to dynamically generate necessary constraints that would otherwise be impossible to insert statically in a MIP model.
Fractional inequality separation, instead is usually harder to perform, and it is concerned in finding strong violated inequalities for fractional solution stemming out from a linear relaxation of a MIP formulation.

In this thesis we are treating a CPTP problem, and more precisely, we are concerned in separating the GSEC, GLM, RCI inequalities presented in Sections \ref{sec:gsec-inequality}, \ref{sec:additional-valid-inequalities}.
This is achieved by finding a set $S \subseteq V_0$, through the usage of appropriate algorithms, that violates any valid inequality.

All the cuts that we implemented, are backed by the same shared separation procedure for both integral solutions and for fractional solutions.
In the next two sections, we describe the common separation procedure used to find good $S \subseteq V_0$ sets.
Then for each cut, we describe how $S$ is used for generating the inequality and when each cut is reported to the MIP solver and when it is instead ignored.

\subsection{Integral separation}
The integral separation procedure is the most important, as this procedure is necessary to generate GSEC cuts dynamically, and to avoid that the MIP solver produces solutions with spurious subtours.
Assume that the MIP solver finds an optimal integer solution $x^* \in \{0, 1\}, y^* \in \{0, 1\}$ that violates a GSEC constraint.
If $x^*$ violates at least a GSEC, it is easy to see that the solution models at least a spurious unconnected subtour that needs to be removed.
In order to detect unconnected subtours, we need first to determine the connected components induced from the $x^*$ solution.

Let $C = \{0, \dots, n_c - 1\}$ be the connected components formed with $n_c = |C| \ge 1$.
Let $cc(i) \in C$ be an array which for each vertex $i \in V$ it encodes to which connected component it belongs to.
Let's fix $cc(0) = 0$ by definition.
The connected components can be computed by a simple depth first search tracing algorithm, for which a pseudocode is provided in Algorithm \ref{src:cc-dfs}.
\begin{algorithm}
	\caption{An algorithm for computing the connected components through a DFS traversal}
	\label{src:cc-dfs}
	\KwData{$x* \in \{0, 1\}$: current optimal integer solution}
	\KwResult{$n_c$: number of connected components}
	\KwResult{$cc(i) \in C$: connected components array $\forall i \in V$}
	$cc(i) \gets -1 \quad \forall i \in V$\;
	$nc \gets 0$\;
	\For{$i\gets0$ \KwTo $N$}{
		\If{$cc(i) < 0$}{
			\Comment{Found a non visited vertex}
			$cc(i) \gets n_c$\;
			$u \gets -1$\;
			\Comment{Traverse the subtour}
			\Do{$u \ge 0$}{
				$v \gets -1$\;
				\For{$j \in V \mid (u, j) \in E, cc(j) < 0, x^*_{uj} \ge 0.5$}{
					\Comment{The body of this loop will execute only once}
					$cc(j) = n_c$\;
					$v \gets j$\;
				}
				$u \gets v$
			}
			$n_c \gets n_c + 1$\;
		}
	}
	\Return{$n_c, cc$}
\end{algorithm}
Then any valid set $S \in V_0$ can be computed in the following way from a MIP integer solution:

\begin{equation}
	S \subseteq V_0 = \left\{ i \mid cc(i) = k  \right\}   \quad \forall k \in C, k \ne 0
\end{equation}

which implies that any connected component that does not contain the depot node, can be used as a valid set $S \subseteq V_0$ for separating inequalities.
If $n_c = 1$ then no $S \subseteq V_0$ can be separated for this integral solution, which in our case simply means that the solution is valid, since no more violated GSECs exist.




\subsection{Fractional separation}


\subsection{GSEC separation}




\subsection{GLM separation}

\subsection{RCI separation}
