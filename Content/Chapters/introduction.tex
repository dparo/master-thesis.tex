\chapter{Introduction}
\label{sec:introduction-chapter}

\section{The Capacitated Vehicle Routing Problem}
\label{sec:intro-cvrp-problem}

The Capacitated Vehicle Routing Problem (\textbf{CVRP}), first presented in \textcite{dantzig1959},
is one of the most studied combinatorial optimization routing problem.
The CVRP is an NP-hard (in the strong sense) problem which can be considered a generalization
of the well-known Travelling Salesman Problem (TSP).
The TSP is a ubiquitous combinatorial optimization problem
in the operations research field,
that asks for the determination of a Hamiltonian circuit of minimum cost.
The CVRP can be defined verbally as finding an optimal route for a transportation/distribution/delivery problem
starting from a common point called the depot,
where a homogeneous fleet composed of a fixed number of trucks, subject to capacity constraints,
need to serve customer demands of a single good (i.e. delivery of gasoline to gas stations).
Given as input: a weighted graph representing the road network,
the customer demands and the vehicle capacity,
the problem consists in determining a set of routes, one for each vehicle,
of minimal overall travel distance starting and ending at the depot.
The set of routes need to serve all the customers in the road network exactly once and no more.

Studying effective solutions methods for the CVRP may lead to tremendous real-world economic
savings for the management of the provision of goods in distribution systems.
Optimal delivery planning can reduce the overall transportation and good costs while
also reducing the waiting time experienced by the customers.
Therefore, studying optimal efficient algorithms and mathematical models for
solving and describing real-world distribution problems, become vital
important for the operational management of a cost-efficient planning processes.

The CVRP belongs to the wider class of problems known as the Vehicle Routing Problems (VRPs).
There are many variations of VRPs proposed in the literature such as
the Vehicle Routing Problem with Time Windows (VRPTW), and many others.
In the VRPTW \parencite{schrage1981} each customer is associated with a time window slot
in which it can be served,
and the vehicles are subject to capacity constraints.
Nonetheless, CVRP is the simpler VRP variant to describe, which
yet to this day, it remains the most central and studied routing problem.

While effective (meta-)heuristic algorithms have been proposed and applied
successfully to many VRP variants to obtain good-enough solutions
in reduced computation time, in this thesis we are mainly concerned
with exact algorithms for solving the CVRP.
Exact algorithms are usually slower than (meta-)heuristics, but given
enough computation time, they can produce a proven optimal solution.
This is achieved by closing the primal-dual bound gap of the objective function.

\medskip

For a fairly complete taxonomy, variants, notions and facts about the VRP, we highly suggest
the fairly complete book \citetitle{toth2014} of \textcite{toth2014}.
This book served as a good reference and played a central role
in laying out this introductory chapter.

\medskip


CVRP is usually defined more rigorously through an Integer Programming (IP) formulation.
The IP formulation is a mathematical tool which can describe combinatorial optimization problems
through the usage of constraints, usually defined through linear inequalities.
In the next section we will provide a more rigorous mathematical
description of the CVRP, and we will present its most commonly employed IP formulations.


\section{Mathematical formulations}
\label{sec:intro-cvrp-mathematical-formulations}

In this section we present the CVRP through some very well known mathematical formulations.
These mathematical formulation are expressed through (Mixed) Integer Programming (MIP, IP)
models.
We present three total mathematical models:
\begin{enumerate}
	\item The two-index arc flow formulation \parencite{laporte1983, laporte1985, laporte1986}.
	\item The three-index arc flow formulation \parencite{golden1977}.
	\item The Set Partitioning (SP) formulation \parencite{balinski1964}.
\end{enumerate}

The first two formulations, traditionally designed
for branch-and-cut (\textbf{BAC}) algorithms, employ a polynomial number of variables
but use an exponential number of constraints.
The latter formulation, instead, makes use of a polynomial number of constraints,
but uses an exponential number of variables.
Despite the SP formulation being older, in later years thanks to algorithmic advances
and the development of efficient branch-and-price (\textbf{BAP}) frameworks, it has become the de facto
state-of-the-art core ingredient for solving CVRP problems (see \cite{pessoa2020}).

Before presenting each formulation we first need to define some basic notation
and mathematical quantities that will be used throughout the remainder of the thesis.

\medskip

The CVRP is traditionally described as a node routing problem modeled through a symmetric and complete graph theoretical problem,
where: (i) the vertices of the network represent the customers and the depot,
(ii) the edges represent road interconnections.
Let $G = \Tuple*{V, E}$ denote a \textbf{complete undirected network}, where $V = \Set*{0, 1, \dots, N - 1}$ denotes the set of nodes,
$E = \Set*{e = \Set*{i, j} = \Set*{j, i} \mid \allowbreak i,j \in V, \allowbreak i \ne j}$ the set of undirected edges,
and $N$ the total number of nodes in the network.
The value $0 \in V$ is used to denote the depot node.
The edge set $E$ has size $|E|$, which can be computed through combinatorial enumeration: $|E| = \frac{N (N+1)}{2}$.
For convenience, we define $V_0 = V \setminus \Set*{0}$ to express the set of customers,
and $N_0 = N - 1$ to denote the total number of customers.
Let $\delta(S)$ with $S \subseteq V$ denote the edges crossing the set $S$ and its complement $\overline{S} = V \setminus S$.
More formally we can express $\delta(S)$ as $\delta(S) = \Set*{ \Set*{i, j} \in E \mid i \in \Expr*{S \cap V}, j \in \Expr*{ \overline{S} \cap V } }$.
For brevity, we also define $\delta(i) = \delta(\Set*{i})$ to denote the set of edges incident to node $i \in V$.
We also define $E(S) = \Set*{e = \Set*{i, j} = \Set*{j, i}\in E \mid i, j \in S}$ to denote the set of edges having both end points in set $S \subseteq V$.

Let $q_{i} \in \R, q_{i} \ge 0 \quad \forall i \in V$ denote the demand function, which represent the required demand that need to be served for vertex $i \in V$.
For convenience, we fix a fictitious demand for the depot: $q_0 = 0$.
Given a set $S \subseteq V$, we define $q(S) = \sum_{i \in S} q_i$ as the total demand of the set $S$.
Let $c_{ij} \in \R, c_{ij} > 0$ denote the distance function between a pair of nodes  $i, j \in V$.
The loop arcs $\Set*{i, i} \notin E$ in CVRP are traditionally not allowed, thus we fix $c_{ii} = \infty$.
We assume a Euclidean CVRP problem, i.e. the distance function is symmetric $c_e = c_{ij} = c_{ji}$ and satisfies the triangle inequality $c_{ij} \le c_{ih} + c_{hj}$.
We are also given the total number of identical trucks $K \in \N_+$ and an upper bound $Q \in \R_+$ representing the capacity of each truck.
For convenience of notation, we also define $\mcK = \Set*{1, \dots, K}$ to denote the set of trucks.
Given a set $S \subseteq V_0$, we denote by $r(S)$ as the minimum number of vehicles required to serve all customers $i \in S$.
The value of $r(S)$ can be obtained by solving an NP-hard Bin Packing Problem associated with the CVRP and set $S$.
As we will see later, it is often simpler to link $r(S)$ to the trivial lower bound of the Bin Packing Problem \parencite{martello1990}:

\begin{equation}
	r(S) \ge \ceil*{\frac{q(S)}{Q}}
\end{equation}

A route $p$ is a loop-back sequence $p = \Tuple*{i_0, i_1, \dots, i_s}$, with $i_0 = 0$ in which
$\Set*{i_1, \dots, i_s} \subseteq V_0$ customers are visited.
The route $p$ has a travel cost of $c_p = c(p) = \sum_{j=0}^s c_{i_j,i_{j+1}}$.
A feasible solution to the CVRP problem consists of \textbf{exactly} $K$ routes (or circuits)
associated with each vehicle starting and ending at the depot node.
In classic CVRP, each customer is visited exactly once, and the sum of the customer demands visited in each tour does not exceed the vehicle capacity $Q$.
An optimal solution to the CVRP is a feasible solution which minimizes the sum of the overall edge weights across all the tours.

\medskip

The TSP can be considered a special case of CVRP where $Q \ge q(V)$ and $K = 1$.
Therefore, all the relaxations and many results obtained for the TSP are valid, or at least extendable, to the CVRP.

\medskip

Some variants of the basic version of the CVRP, not considered in this thesis, allows using only a subset of the total available vehicles,
or consider a heterogeneous fleet characterized by different capacities $Q_1, \dots, Q_k$.
In the remainder of the section we introduce the two most common IP mathematical formulations for the classical version of the CVRP.

\subsection{The two-index arc flow formulation}
\label{sec:intro-cvrp-two-index-flow-formulation}

The two-index arc flow formulation (2F) was first presented in \cite{laporte1983, laporte1985} for the symmetric case,
and later generalized to the undirected case in \cite{laporte1986}.

The two-index arc flow formulation is traditionally tackled with branch-and-cut frameworks.
We define a set of integer variables $x_e \in \Set*{0, 1, 2}$ to indicate the number of times
a vehicle traverses edge $e = \Set*{i, j} = \Set*{j, i} \in E$ in the optimal solution.
There are $O(N^2)$ number of integer variables in the model.
The two-index arc flow formulation can be described as an Integer Programme (IP):

\begin{align}
	\min_{x} \quad z_\mt{2F}(x) & = \sum_{e \in E} c_e x_e \label{eq:two-index-flow-obj-func}                                                                                        \\
	                            & \sum_{e \in \delta(i)} x_e = 2                              & \quad \forall i \in V_0 \label{eq:two-index-flow-two-edges-incident-per-customer}    \\
	                            & \sum_{e \in \delta(0)} x_e = 2 K                            & \label{eq:two-index-flow-two-k-edges-incident-in-the-depot-node}                     \\
	                            & \sum_{e \in \delta(S)} x_e \ge 2 r(S)                       & \quad \forall S \subseteq V_0,\ |S| \ge 1 \label{eq:two-index-flow-ccc}              \\
	                            & x_e                   \in \Set*{0, 1, 2}                    & \quad \forall e \in \delta(0) \label{eq:two-index-flow-x-mip-var-bounds-depot}       \\
	                            & x_e                   \in \Set*{0, 1}                       & \quad \forall e \in E \setminus \delta(0) \label{eq:two-index-flow-x-mip-var-bounds}
\end{align}

where $z_\mt{2F}(x)$, as defined in \eqref{eq:two-index-flow-obj-func}, is the objective function meant to minimize the overall routing cost (travel time).
Constraint \eqref{eq:two-index-flow-two-edges-incident-per-customer} is the degree constraint which imposes flow conservation: exactly two incident edges must be picked for each customer.
Constraint \eqref{eq:two-index-flow-two-k-edges-incident-in-the-depot-node}, is the degree constraint at the depot, it forces that exactly $2K$ incident edges at the depot are picked, thus forcing exactly $K$ routes to be constructed.
Constraints \eqref{eq:two-index-flow-x-mip-var-bounds-depot} and \eqref{eq:two-index-flow-x-mip-var-bounds} forces each edge to be traversed at most once,
except for all edges incident at the depot.
The edge-case modeled in constraint \eqref{eq:two-index-flow-x-mip-var-bounds-depot} is necessary to allow single-customer routes.
Constraint \eqref{eq:two-index-flow-ccc}, are the so-called Capacity Cut Constraints (CCC), also called Rounded Capacity Inequalities (RCI), they function both:
(i) as a Subtour Elimination Constraints (SECs), by imposing connectivity of the solution by avoiding the formation of spurious unconnected subtours,
and (ii) as a capacity constraint, by imposing that any customer set $S$ is crossed by a number of edges not smaller than $r(S)$.
Recall that, $r(S)$ represents the minimum number of vehicles needed to serve all customers in set $S$,
also, $r(S)$ always satisfies $r(S) \ge 1$ for non-trivial CVRP instances: $q(S) > 0$.

It was shown in \textcite{cornuejols1993}, that it is possible to replace $r(S)$ in constraint
\eqref{eq:two-index-flow-ccc}, with the much simpler Bin Packing Problem lower bound $\ceil*{q(S) / Q}$
thus obtaining the following inequality:

\begin{equation}\label{eq:two-index-flow-ccc-bpp-lb}
	\sum_{e \in \delta(S)} x_e \ge 2 \ceil*{\frac{q(S)}{Q}}   \quad \forall S \subseteq V_0, |S| \ge 1
\end{equation}

The less tight inequality of \cref{eq:two-index-flow-ccc-bpp-lb} is sufficient to optimally solve
the two-index arc flow formulation.
Although, a better lower bound for the Bin Packing Problem can improve the linear
relaxation, thus reducing the number of branching occurrences.

Traditionally, the CCC constraints in \cref{eq:two-index-flow-ccc}, are usually transformed in the so called Generalized Subtour Elimination Constraints (GSEC),
by means of the degree constraints \labelcref{eq:two-index-flow-two-edges-incident-per-customer,eq:two-index-flow-two-k-edges-incident-in-the-depot-node}:

\begin{equation}\label{eq:cvrp-2flow-gsec}
	\sum_{e \in E(S)} x_{ij} \le |S| - r(S) \quad \forall S \subseteq V_0,\ |S| \ge 1
\end{equation}

where, again, $r(S)$ may be replaced by the trivial Bin Packing Problem lower bound $\ceil*{q(S) / Q}$.

The GSEC avoid the formation of spurious unconnected subtours and impose that at least $r(S)$ edges leave set $S$.
The number of GSEC (or CCC) inequalities appear in exponential number in the two-index formulation model,
thus making a direct solution of the linear programming relaxation impractical.
To overcome this issue, it is possible to avoid adding the GSEC inequalities statically in the model.
Instead, an appropriate cutting-plane algorithm and separation procedure may be employed to generate dynamically,
during the running time of the branch-and-cut algorithm,
only the necessary (violated) GSEC constraints.

Another approach is to avoid the usage of the exponential number of SECS entirely.
This is the approach taken by the so-called compact models (see \cite{miller1960, christofides1979, desrochers1991}).
These models make use of a polynomial number of constraints.
Unfortunately these compact formulations are known to produce significantly weaker linear relaxations.
In fact, it has been mathematically proven,
that the SECs are very strong for the TSP: they are facet-defining for the polytope;
i.e. they uniquely characterize the convex-hull \parencite{grotschel1975}.
However, similar mathematical proofs cannot be extended to the CVRP,
since due to the more complex structure of this generalized problem,
little satisfactory results have been obtained in studying the polyhedral characteristics
for even the standard variation of the VRP, see \textcite{campos1991, cornuejols1993}.

\subsection{The three-index arc flow formulation}
\label{sec:intro-cvrp-three-index-flow-formulation}

When modeling more "colorful" variations of the CVRP, the two-index arc flow model falls shorts in providing sufficient descriptive power.
For example, the simple CVRP variant where the fleet of trucks is heterogeneous and characterized by capacities $Q_1, \dots, Q_K$,
cannot be described with the two-index arc flow formulation, since there's no clear one-to-one mapping on which truck crosses an edge $e \in E$.

The three-index arc flow formulation (3F), first presented in \textcite{golden1977}, fixes this issue.
The 3F formulation makes use $O(N^2 K + N K)$ integer variables.
A set of integer variables $x_{ek} \in \Set*{0, 1, 2},\ e = \Set*{i, j} \in E,\ k \in \mcK$ is used to encode the number of times a truck $k$ traverses an $e \in E$.
Another set of binary variables $y_{ik} \in \Set*{0, 1},\ i \in V,\ k \in \mcK$ is used to model whether truck $k$ covers a node $i \in V$.


The three-index arc flow formulation can be described as an Integer Programme (IP):


\begin{align}
	\min_{x, y} \quad z_\mt{3F}(x, y) & = \sum_{k \in \mcK} \sum_{e \in E} c_{e} x_{ek} \label{eq:three-index-flow-obj-func}                                                                                                                           \\
	                                  & \sum_{k \in \mcK} y_{ik} = 1                                                         & \quad \forall i \in V_0                                              \label{eq:three-index-flow-all-customers-visited}  \\
	                                  & \sum_{k \in \mcK} y_{0k} = K                                                         & \label{eq:three-index-flow-tour-starts-and-ends-at-depot}                                                               \\
	                                  & \sum_{e \in \delta(i)} x_{ek} = 2 y_{ik}                                             & \quad \forall i \in V,\ \forall k \in \mcK \label{eq:three-index-flow-force-visited-customer-if-flow}                   \\
	                                  & \sum_{i \in V} q_i y_{ik} \le Q                                                      & \quad \forall k \in \mcK \label{eq:three-index-flow-force-resource-upper-bound}                                         \\
	                                  & \sum_{e \in \delta(S)} x_{ek} \ge 2 y_{hk}                                           & \quad \forall h \in S,\ \forall S \subseteq V_0,\ |S| \ge 2,\ \forall k \in \mcK \label{eq:three-index-flow-secv1}      \\
	                                  & x_{ek}                   \in \Set*{0, 1, 2}                                          & \quad \forall e \in \delta(0),\ \forall k \in \mcK             \label{eq:three-index-flow-x-mip-var-bounds-depot}       \\
	                                  & x_{ek}                   \in \Set*{0, 1}                                             & \quad \forall e \in E \setminus \delta(0),\ \forall k \in \mcK             \label{eq:three-index-flow-x-mip-var-bounds} \\
	                                  & y_{ik}                    \in \Set*{0, 1}                                            & \quad \forall i \in V,\ \forall k \in \mcK  \label{eq:three-index-flow-y-mip-var-bounds}
\end{align}

where $z_\mt{3F}(x, y)$, as defined in \eqref{eq:three-index-flow-obj-func}, is the objective function to be minimized (i.e. the overall travel distance).
Constraint \eqref{eq:three-index-flow-all-customers-visited} forces all customers to be served exactly once.
Constraint \eqref{eq:three-index-flow-tour-starts-and-ends-at-depot} forces all the truck tours to start at the depot and end at the same spot.
Constraint \eqref{eq:three-index-flow-force-visited-customer-if-flow} binds the $y_{ik}$ variables to the corresponding $x_{ijk}$ variables, by ensuring that if a truck's route passes through a vertex, then the corresponding node is marked as visited.
Constraint \eqref{eq:three-index-flow-force-resource-upper-bound} is the resource upper bound constraint and it ensures that the demand served by each truck does not exceed the truck capacity.
Constraints \eqref{eq:three-index-flow-secv1} are the Generalized Subtour Elimination Constraints (GSECs), they impose the connectivity of the route and are used to avoid the formation of spurious unconnected subtours.
Constraints \eqref{eq:three-index-flow-x-mip-var-bounds-depot} and \eqref{eq:three-index-flow-x-mip-var-bounds} forces each edge to be traversed at most once,
except for all edges incident at the depot.
The edge-case modeled in constraint \eqref{eq:three-index-flow-x-mip-var-bounds-depot} is necessary to allow single-customer routes.
Finally, constraint \eqref{eq:three-index-flow-y-mip-var-bounds} bounds and forces integrality for the $y_{ik}$ binary variables.

Constraint \eqref{eq:three-index-flow-secv1} may be replaced in an equivalent form with traditional (non generalized) TSP subtour elimination constraints (see \textcite{fisher1981}):

\begin{equation}\label{eq:three-index-flow-secv2}
	\sum_{e \in E(S)} x_{ek} \le |S| - 1 \quad \forall S \subseteq V_0, |S| \ge 2,\ \forall k \in \mcK
\end{equation}

Since the number of (G)SECs is exponential in the number of nodes $N$, they are usually not inserted statically in the model but are generated lazily within the running time of the resolution process.

The three-index arc flow model generalizes the two-index version.
In fact, the two-index arc flow model may be viewed as a special case of the three-index by defining:


\begin{equation}
	x_e = \sum_{k \in \mcK} x_{ek} \quad \forall e \in E
\end{equation}

However, the three-index arc flow formulation suffers a major downside compared to the two-index version.
When modeling homogeneous fleets CVRPs the 3F model suffers from a multiplicity of the solution space.
In fact, since all the vehicles share the same capacity,
new feasible solutions can be obtained through symmetry by simply permuting the identity $k \in \mcK$ of each truck.


\subsection{The Set Partitioning (SP) formulation}
\label{sec:intro-set-partition-formulation}

The Set Partitioning (SP) formulation, sometimes also called Path Flow formulation, is an extended formulation, which was originally presented in \textcite{balinski1964}.
It works substantially differently from the two/three-index arc flow formulation or many other commonly encountered IP models.
The SP formulation uses a very small number of constraints while offloading much of the search-space complexity to an exponential number of binary variables.


The SP formulation can be viewed as a Dantzig-Wolfe decomposition \parencite{dantzig1960}
and commodity aggregation \parencite{desaulniers1998}
of the three-index arc flow formulation.
Let $P = \Set*{p \mid p\ \text{is a single-truck feasible route}}$ be the set of all feasible routes.
Let $\lambda_p \in \Set*{0, 1}$ be a binary variable indicating whether route $p$ is selected.
Let $a_{ip} \in \Set*{0, 1}$ $a_{ep} \in \Set*{0, 1}$ be "static encodings" (binary coefficients)
for a route $p \in P$ for respectively covering a vertex $i \in V$ or an edge $e \in E$.

We recall that $c_p = c(p)$ represents the cost of a feasible route $p \in P$, which can be trivially computed in $O(N)$.
The SP model forces $K$ routes $\Tuple*{p_1, \dots, p_K} \in P^K$ to be included in the optimal solution.

The SP formulationis is described through an Integer Programme (IP):


\begin{align}
	\min_{\lambda} \quad z_\mt{SP}(\lambda) & = \sum_{p \in P}  c_p \lambda_p \label{eq:set-partitioning-obj-func}                                                                                                                                           \\
	                                        & \sum_{p \in P}  a_{ip} \lambda_p = 1                                 & \quad \forall i \in V_0                                              \label{eq:set-partitioning-customers-visited-by-exactly-one-route} \\
	                                        & \sum_{p \in P} \lambda_{p} = K\label{eq:set-partitioning-K-routes}                                                                                                                                             \\
	                                        & \lambda_p                    \in \Set*{0, 1}                         & \quad \forall p \in P \label{eq:set-partitioning-lambda-mip-var-bounds}
\end{align}

where, $z_\mt{SP}(\lambda)$, as defined in \eqref{eq:set-partitioning-obj-func} is the objective function to be minimized (i.e. the overall travel distance).
Constraint \eqref{eq:set-partitioning-customers-visited-by-exactly-one-route} forces each customer to be covered by exactly one route.
Constraint \eqref{eq:set-partitioning-K-routes} enforces that exactly $K$ routes are selected.
Finally, constraint \eqref{eq:set-partitioning-lambda-mip-var-bounds} is the bounding and integrality constraints for binary variables $\lambda_p \ \forall p \in P$.

As one may guess, due the exponential number of binary variables, the SP formulation cannot be instantiated nor directly solved.
However, a variant of the SP formulation can be tackled efficiently by Column Generation (CG) approaches embedded inside a branch-and-price (BAP) framework.
Branch-and-price frameworks and column generation have been applied with high success to the vehicle routing problems.


As, \textcite{toth2002} points out, if the distance matrix satisfies the triangle inequality,
than it is possible to rewrite the SP formulation into a totally equivalent Set Covering (SC) formulation
by substituting \cref{eq:set-partitioning-customers-visited-by-exactly-one-route} in favor of the simpler inequality:

\begin{equation}\label{eq:set-covering-customers-visited-by-exactly-one-route}
	\sum_{p \in P}  a_{ip} \lambda_p \ge 1  \quad \forall i \in V_0
\end{equation}

Under the triangle inequality assumption, any feasible solution for the SP formulation is also feasible for the SC formulation.
Transforming the SP to the SC formulation vastly shrinks (halves) the size of the dual solution space.

\medskip


The SP formulation has two main advantages.
First, its linear relaxation provides excellent lower bounds \parencite{bramel1997}.
Second, it can handle many VRP variants,
even described through very complex constraints,
since their definitions are captured within the definition of the set $P$ itself.


\medskip

In the next sections we will introduce
the branch-and-price (BAP) framework and the Column Generation (CG) approach,
key components employed in modern state-of-the-art CVRP solvers.


\section{Branch and Price}
\label{sec:intro-branch-and-price}

Branch-and-price (BAP) frameworks are in essence a branch-and-bound (BAB) scheme, i.e. making use of a search tree, that originates when solving the SP formulation for vehicle routing problems.
Compared to more traditional branch-and-cut (BAC) frameworks, their primary focus is the usage of a Column Generation (CG) technique for improving the dual bound, see \textcite{righini2008}.
BAP frameworks were first applied successfully in \textcite{gilmore1961} to the Cutting-Stock problem.
An extension of the BAP framework, the so-called branch-and-cut-and-price (BPC) framework,
is in essence a branch-and-bound (BAB) algorithm where dual bounds are obtained through column generation (CG)
and cutting-planes are added to strengthen the linear relaxations associated to each node of the search-tree.


\subsection{Column generation and the Pricing Problem}
\label{sec:column-generation-and-pricing-problem}

Consider the \textbf{Master Problem} (MP) defined
as the linear relaxation of the SP formulation obtained by relaxing the integrality constraints:

\begin{align}
	\min_{\lambda} \quad z_\mt{MP}(\lambda) & = \sum_{p \in P}  c_p \lambda_p \label{eq:mp-obj-func}                                                                                                                             \\
	                                        & \sum_{p \in P}  a_{ip} \lambda_p = 1                   & \quad \forall i \in V_0                                              \label{eq:mp-customers-visited-by-exactly-one-route} \\
	                                        & \sum_{p \in P} \lambda_{p} = K\label{eq:mp-K-routes}                                                                                                                               \\
	                                        & 0 \le \lambda_p \le 1                                  & \quad \forall p \in P \label{eq:mp-lambda-mip-var-bounds}
\end{align}


When solving the MP,
at each iteration of the simplex algorithm we seek for a non-basic variable (i.e. column)
to price out and enter the basis.
This is achieved by evaluating the dual variables $\pi \in \R^{N}$
associated with constraints \eqref{eq:mp-K-routes}, \eqref{eq:mp-customers-visited-by-exactly-one-route}.
Due to the huge size of the set of routes $P$,
it is computationally intractable to evaluate numerically the dual variables $\pi \in \R^{N}$.

\medskip

Therefore, in BAP frameworks we consider only a small subset of columns $\mcP \subseteq P$,
obtaining the following linear program:

\begin{align}
	\min_{\lambda} \quad z_\mt{RMP}(\lambda) & = \sum_{p \in \mcP}  c_p \lambda_p \label{eq:rmp-obj-func}                                                                                                                              \\
	                                         & \sum_{p \in \mcP}  a_{ip} \lambda_p = 1                    & \quad \forall i \in V_0                                              \label{eq:rmp-customers-visited-by-exactly-one-route} \\
	                                         & \sum_{p \in \mcP} \lambda_{p} = K\label{eq:rmp-K-routes}                                                                                                                                \\
	                                         & 0 \le \lambda_p \le 1                                      & \quad \forall p \in \mcP \label{eq:rmp-lambda-mip-var-bounds}
\end{align}

which takes the name of \textbf{Restricted Master Problem} (RMP).

In BAP frameworks, we seek to solve the so-called \textbf{Pricing Problem} (PP) defined as:

\begin{equation}
	{c^\star_p} = \min_{p \in P} \Set*{ \bar{c_p} = \sum_{e = \Set*{i, j} \in E} \Expr*{c_{e} - \frac{\pi_i + \pi_j}{2}} a_{ep}  }
\end{equation}

where $\bar{c_p}$ denotes the reduced cost of a route $p \in P$
and $c^\star_p$ is the reduced cost of the optimal route $p^\star \in P$
that leads to the best dual bound improvement.

Any $p \in P$ which satisfies $\bar{c_p} < 0$ is a valid column which can enter the basis of the RMP.
The BAP solver needs to smartly manage the set $\mcP \subseteq P$, which it stores it inside a pool.
It is responsibility of the BAP framework to efficiently manage which routes
to preserve or drop from $\mcP$ during the running time of the resolution process.


The resolution method, or algorithm,
used to solve the PP is usually called \textbf{oracle} or \textbf{pricer} in the literature.
The oracle needs to solve the pricing sub-problem which, due to the definition of the set $P$,
coincides with solving an Elementary Shortest Path Problem with Resource Constraints (ESPPRC)
over a \textbf{new directed symmetric} network with weights
$\bar{c_{ij}} = c_{ij} - \frac{1}{2} \pi_i - \frac{1}{2} \pi_j$.
The ESPPRC problem asks for an elementary path (i.e. each vertex visited at most once) starting
from a vertex, called a source vertex, and ending in another vertex, called the sink vertex.
In the ESPPRC, the depot node is replaced by two vertices (one source, on sink)
and the newly obtained network is characterized by $N + 1$ vertices.

\medskip

The column generation (CG) is an iterative algorithm which alternates between two phases \parencite{desaulniers2018}:
\begin{enumerate}
	\item The simplex algorithm for solving the RMP, which is characterized by one or more pivot operations.
	\item One or several iterations of the Pricing Problem (PP) solved by invoking the pricer algorithm.
	      The simplex algorithm invokes the pricer to verify whether other pivot operations
	      can be performed for improving the dual bound.
	      The pricer algorithm usually lives in a separate external code module from the branch-and-price code.
\end{enumerate}

The column generation procedure stops mainly under two scenarios:
(i) when no more negative reduced cost routes exist, i.e. the PP outputs a $p^\star$ achieving $c^\star_p \ge 0$,
(ii) the CG procedure tails off, i.e. the gained dual bound improvements compared to the running time to generate a column become suboptimal (optional).

If after the column generation procedure
the solution to the RMP $\lambda^*$ satisfies the integrality constraints,
$\lambda^\star_p \in \Set*{0, 1} \quad \forall p \in \mcP$,
no branching or cutting planes are required,
and the new solution $\lambda^*$ can be used to update the incumbent.
If, instead,
$\exists p \in \mcP \mid \lambda^\star_p \notin \Set*{0, 1}$
then a branching strategy is usually necessary
in order to seek for the best integral solution.
When all the nodes of the branch-and-bound tree have been explored or pruned,
then the CVRP problem is solved to optimality
and the current incumbent solution becomes the optimal solution
$(p_1, \dots, p_K) \mid \lambda^\star_{p_i} = 1$.

\medskip

It is important to also note that
the CG doesn't need to solve the PP optimally at each iteration of the simplex algorithm.
To improve the dual bound,
it is usually enough to find any $p \in P$ achieving $\bar{c_p} < 0$,
which allow the usage of heuristic algorithms
especially during the very first few pricing iterations,
where finding good reduced cost columns is surprisingly easy.

\subsection{Branching, Route Enumeration and Cut Generation}
\label{sec:intro-branching-and-cut-generation-within-bap-frameworks}

In order to satisfy the integrality constraints for the SP formulation,
solving the RMP at the root node is almost always not enough.
The CG algorithm may in fact terminate with a non-zero duality gap.
Therefore,
a search-tree and a branching scheme is employed
to seek for the optimal integral solution $\lambda^\star_p \in \Set*{0, 1} \quad \forall p \in P$.

Although non strictly-necessary, modern BAP also use
cut generation procedures to efficiently improve the dual bound and improve the convergence speed.
Modern BAP frameworks
are in fact a hybridization between a BAP and a BAC framework,
making them a branch-and-cut-and-price (BCP) frameworks.
Some notable works integrating cutting-planes and proposing
a BCP approach for the VRP can be found \textcite{fukasawa2006, ropke2012}.

\medskip

It is important to note however that branching is not a strictly required operation
Route enumeration is another technique that can be used in place of branching
for obtaining integral solutions.
In route enumeration, all elementary routes that may belong to the VRP optimal solution are enumerated,
and an SP formulation containing all these enumerated routes are solved through a MIP.
The problem of this approach is the possibly huge number of routes that needs to be enumerated,
and this quantity is highly linked to the tightness of the duality gap,
and with the average length of a tour $N / K$.
Route enumeration is an operation that takes exponential space complexity,
but it can drastically improve the performance of the BPC on some instances.
The major contributions employing route enumeration in place of branching can be found in
\textcite{baldacci2008, baldacci2011, contardo2014}.

Modern BPC frameworks instead take a hybrid approach by combining branching and route enumeration
(see \cite{pessoa2008a, pessoa2009, pecin2017, pessoa2020}).
After the convergence of the column generation algorithm route enumeration is attempted.
If the number of enumerated routes starts to exceed a maximum limit, enumeration
is preemptively aborted and conventional branching is applied.
Once the primal-dual bound gap reaches desirable levels, the route enumeration
procedure will enumerate all routes under the maximum limit.
At the point the associated RMP formulation can be solved efficiently through a MIP.

We will not concentrate much of our attention on route enumeration in this
thesis, since their presence doesn't influence the pricing problem.
Nonetheless, it's important to know about their existence and role within
the branch-and-price frameworks.

\medskip

Branching and cut generation in BCP frameworks are more delicate operations
compared to more traditional BAC frameworks due to the presence of the pricing problem.
As classified in \textcite{dearagao2003},
depending on the branching and cut generation schemes employed,
two classes of inequalities are possible:
\textbf{robust} versus \textbf{non-robust} inequalities.

A \textbf{robust} inequality is an inequality which can be safely added to the RMP without altering the structure of the set of feasible paths $P$.
That is, robust inequalities do not require explicit modeling in the PP formulation and instead manifest their contribution directly in the dual variables $\pi$.
An oracle, therefore, after the introduction of a robust inequality in the RMP, needs to solve the same ESPPRC problem but with slightly different weights associated on each edge.

A \textbf{non-robust} inequality, instead, is much harder to handle since it changes the structure of the set of feasible paths $P$.
Non-robust inequalities may in general be quite strong but, unfortunately, require explicit modeling and support within the oracle.
These types of inequalities can drastically complicate the pricing problem, trading better dual improvements for increased column generation times.
Therefore, their usage must be assessed on a case-by-case basis.
Non-robust inequalities may present themselves both in the branching and cut-generation phases.

In this thesis we will mostly concentrate on branching and cut generation schemes which make use of \textbf{robust} inequalities.
Refer to \textcite{desaulniers2011} for an introduction in cutting planes for BAP algorithms.



\begin{comment}
When a violated inequality in the two/three-index formulation is found, it is decomposed at runtime and introduced in the master problem.
\end{comment}

\begin{comment}
\cite{toth2014}
Anyway, even if Ω only contains elementary routes, the bounds given by formulation
VRP4 (gaps between 1% and 4% are typical in the instances from the literature) are not
good enough to be the basis of efficient exact algorithms. For this purpose, VRP4 must be
reinforced with additional cuts. In fact, all the recent methods mentioned in Section 3.2
perform some kind of combined generation of both columns and cuts. Section 3.4 will
present the main families of cuts used in those methods. Some of those
\end{comment}


\subsubsection{Branching}
\label{sec:bap-branching}

Branching directly on the $\lambda_p$ variables of the SP formulation is a form of non-robust branching.

Many branching schemes for the CVRP are mere extension of the one used for the TSP.
Probably, the most simple and known branching scheme in the \textbf{branching on arcs} proposed in \textcite{christofides1969a},
and later re-adapted in different forms in \textcite{fisher1994a, miller1995}.
Also, some reduction and dominance rules may be employed to remove some arcs
which can be proved that they cannot belong to an optimal solution,
thus it is possible to branch with a single descendant node to eliminate
a good portion of the solution space.


Branching on a generic $\lambda_p$ of the SP formulation is a form of non-robust inequality,
that will lead to a harder pricing problem.

Therefore, by noting that it is possible to map variable $x_e$ of the two-index arc flow formulation
to the SP formulation by noting that:

\begin{equation}
	x_e = \sum_{p \in P} \Expr*{\sum_{e \in E} a_{ep}} \lambda_p
\end{equation}

where $a_{er}$ is a binary coefficient and denotes the number of times edge $e$ is
crossed by route $p$.
Thus, it is possible in the SP formulation to branch on an edge $e$, which
is a robust form of inequality.


\subsubsection{Families of Cuts}
\label{sec:families-of-cuts}

First attempts in proposing valid inequalities for the CVRP,
with the aim to improve the linear relaxation,
were obtained by generalizing constraints for the TSP, see \textcite{naddef1993}.

Some non-robust cuts were also deployed for the CVRP,
showing that they can be effectively used if they are separated
carefully, by taking into consideration the aggravation of the pricing problem.
Major contributions in the non-robust cuts domain are: the subset row inequalities in \textcite{jepsen2008a},
the strong capacity inequalities in \textcite{baldacci2008}.


As is done in \textcite{toth2014}, families of valid inequalities for the CVRP can
be separated in different families.

\begin{itemize}
	\item \textbf{TSP-Related Valid inequalities}.
	      \textcite{naddef1993} showed that it is possible to re-adapt (by putting into a tight triangular form)
	      every valid constraint for the symmetric TSP to the CVRP.
	\item \textbf{Capacity Constraints}
	      The capacity constraints can be expressed in the form $\sum_{e in \delta(S)} x_e \ge 2 r(S) \quad \forall S \subseteq V_0, |S| \ge 2$.
	      Depending on how $r(S)$ is computed, the set of constraints take different names.
	      If $r(S) = \sum_{i \in S} q_i / Q$, we have the so-called fractional capacity inequality.
	      If $r(S) = \ceil*{\sum_{i \in S} q_i / Q}$, we have the so-called rounded capacity inequality.

	\item \textbf{Multistar Inequalities}, proposed in \textcite{araque1990}.
	      \textcite{letchford2002} propose extended version of inequalities for this family of cuts.
	      The idea lies in first computing an upper bound on the value of $x(E(S))$, then
	      for each value of $x(E(S))$ an upper boun on the $x(\delta(S) \cap \delta(T))$.
	      The related inequalities called generalized large multistar inequalities were proposed by \textcite{gouveia1995}.
\end{itemize}


Other contributions can be classified in:
(i) strengthened capacity cuts proposed in \textcite{baldacci2008}, which can be considered a
non-robust tighter version of the CCC (rounded capacity cuts),
(ii) subset row cuts proposed in \textcite{jepsen2008a}, a non-robust
inequality similar to a less general clique cuts that leads to less impact in the pricing problem,
(iii) strong degree cuts proposed in \textcite{contardo2011}, a specialized version
of the strengthened capacity cuts,
(iv) limited memory subset row cuts proposed in \textcite{pecin2017}, a generalization
of the non-robust subset row cuts which mitigates the complexity impact on the pricing problem,
(v) extended capacity cuts proposed in \textcite{pessoa2008a, pessoa2009}, a
generalization of the rounded capacity cuts.


\subsection{Solving the Pricing Problem}
\label{sec:intro-solving-the-pricing-problem}

\mytodo{Write this section or merge it}

The label-setting algorithm work by label construction and propagation from node to node.
The dominance rules in the label-setting algorithm allows the oracle
to efficiently prune the search space by ignoring dominated labels, thus speeding
up the resolution process tremendously.
The dominance criteria was introduced in \cite{feillet2004}.

In order to simplify the pricing problem further,
some authors started to propose to relax the elementarity condition
to speed up the convergence of the label-setting algorithm, worsening however, the dual improvement.
It is in fact possible to drop the elementarity constraints, only if, the BAP framework supports
branching on the edges of the original three-index flow formulation.
Notable contributions in relaxing the elementarity constraints include:
(i) the q-route relaxation suggested in \textcite{christofides1981},
(ii) a state-space relaxation procedure suggested in \textcite{christofides1981a},
(iii) shortest path relaxation suggested in \textcite{desrosiers1984},
(iv) q-routes with $k$-cycle elimination in \textcite{irnich2006},
(iv) ng-routes relaxation proposed in \textcite{baldacci2011}.

The q-routes are routes not satisfying the elementarity condition which
can therefore serve the same customer twice. For
each visit of the same customer its demand will be counted again.
The advantage of using the q-routes relaxation is that the pricing problem
can be solved with a pseudo-polynomial time algorithm in \textcite{N^2 Q}
operations for the CVRP.
Therefore, when the CVRP vehicle capacity is loose, the label-setting algorithm
even when considering a very-relaxed form of elementarity, its running
time get worse as the capacity bound $Q$ increases.
If the label setting algorithm considers only elementary routes,
its complexity becomes exponential in $O(2^N Q)$, proving that in
either case, longer routes are more challenging to price
for the label-setting algorithm \parencite{toth2014}.
The q-routes with $k$-cycle elimination are a generalization of the q-routes
in which multiple visits to a customer $i \in V_0$ are only allowed
if at least $k$ other vertices are visited in between.
Elementary routes are therefore a special case of q-routes with $N$-cycle elimination.
Unfortunately, for practical cases as is point out in \textcite{fukasawa2006} the value
of $k$ never exceeds 4 since this would complicate too much the cycle elimination logic
and the pricing problem.
ng-Routes are instead a partial elementarity constraint
which is a simpler alternative to cycle-elimination.
The idea is to forbid a subset $\hat{V_0} \subset V_0$ of customers from being revisited.
The ng-routes are efficiently implementable in the label-setting algorithm.





Some general works instead were devoted in speeding up the performance of the label
setting algorithm:
(i) stronger dominance rules and completion bounds,
(ii) a state-space relaxation procedure suggested in \textcite{christofides1981a},
(iii) bidirectional search proposed in \textcite{righini2006},
(iv) decremental state space relaxation in \textcite{boland2006, righini2008},
(v) decremental state space relaxation extended to handle ng-sets,
where the size of the ng-sets are increased dynamically \textcite{martinelli2014}.


As, the average number of customers per route $N / K$ increases,
the number of pricing iterations per column generation increases.
Therefore, \textcite{dumerle1999, pessoa2013} propose a dual stabilization
technique to improve the convergence speed of the column generation process.
Another reasonable approach to speed-up the column generation process
is the use of faster pricing heuristic algorithms. The exact
pricing state is called only when the pricing heuristic fails
at determining a valid reduced-cost route.
\textcite{fukasawa2006} proposes a modification of the label-setting
algorithm to use it as an heuristic pricer.



The main idea behind partially relaxing the elementarity condition consists
in making the pricing problem more tractable, while at the same time,
keep bounds as close as possible to the elementary route bound.


The first BCP algorithm, using full elementarity routes, by not relaxing the elementary
condition, was done in \cite{chabrier2006},
but, general k-cycle elimination algorithms for the pricing problem, have since not been studied
in great details.

\subsection{Shortest Path Problem with Resource Constraints}
If there are no negative cost cyles, e.g. when the reduced cost variables are positive $\bar{c_{ij}} \ge 0$,
the ESPPRC problem is solvable in polynomial time, since the elementarity conditions are guaranteed
to be satisfied in this case.
In this particular case, some authors have proposed efficient methods to tackle this case:
\cite{beasley1989}, \cite{carlyle2008}, \cite{dumitrescu2003}, \cite{muhandiramge2009}.
These proposed approaches work under the assumption that no negative cost cycle is present,
and use lagrangian relaxation to relax the capacity constraints.


\subsection{Elementary Shortest Path Problem with Resource Constraints}
In the case where the network may be contain negative cost cycles, the
elementarity condition must be explicitely modeled, or relaxed, in order
to obtain reasonable dual bound solutions for the CVRP.
\textcite{feillet2004} proposes a dynamic programming algorithm where
the elementary property is handled through the usage of an additional resource
bound to each node.
\textcite{righini2006} proposes a bi-directional dynamic programming algorithm to solve the ESPPRC.


\subsection{Obtaining Integer Solutions}

Through: traditional branch and bound where branching is done on an arc or a hyperplane in the original space, or by using enumeration.
The enumeration approach was proposed by \textcite{baldacci2008} in where they prove it to be very successful when applied to the CVRP.


\begin{comment}
\cite{jepsen2011}
The other method is enumeration which has proven to be very successful
for both cvrp[1] and vrptw[3]. In enumeration an upper bound U B and
a lower bound LB are used. From reduced cost fixing of a binary variable
it is know that any non basic column with a reduced cost strictly greater
than the gap ub − lb can not be part of an integer solution which is an
improvement of the current solution. This complete set of columns can be
found by solving an espprc using the dominance rule in proposition 5 and
bounding functions. Once we have added the columns with reduced cost less
than or equal to the gap the resulting problem can be solved as an integer
optimization problem.
\end{comment}

\section{Literature Review}
\label{sec:intro-literature-review}

\mytodo{Write this section, by integrating the literature as I read it}


\textcite{dantzig1959} propose for the first time the CVRP problem,
followed a few years later from \textcite{clarke1964} proposing
an effective greedy heuristic algorithm.
In the last 60 years, a huge number of contributors in
the operations research community have studied and proposed many
mathematical models, and algorithms (both exact and (meta-)heuristic)
for solving the VRP.
Up to the late 1980s, the exact approaches for tackling the CVRP was
based on tree-search algorithm employing branch-and-bound schemes
(see \textcite{christofides1969a, christofides1981, laporte1986}),
sometimes employing Lagrangian duality relaxation (see \textcite{fisher1994a, miller1995}),
or additive approaches (see \textcite{fischetti1994a, hadjiconstantinou1995}).

From the 1980s to the first 2000s, some authors applied branch-and-cut
algorithms to the VRP.
\textcite{laporte1985}, proposes the two-index arc flow formulation
and a branch-and-cut algorithm to solve it.
Later \textcite{augerat1995a}, proposes a branch-and-cut schemes
employing extra valid inequalities.
Later, \textcite{lysgaard2004}, proposes a new and more modern separation procedures for
the valid inequalities known at the time.
Other notable branch-and-cut-price based contributions
can be found in \textcite{araqueg1994, augerat1995, achuthan1996, blasum2000, ralphs2003, achuthan2003, baldacci2004}.
These works based on branch-and-cut frameworks, showed that CVRP instances, even with small number of customers (less than 100) proved
to be very challenging to solve exactly.


One of the very few first attempts of applying
the SP formulation and a column generation scheme can
be attributed to\textcite{desrosiers1984, agarwal1989}.
These authors, showed that the column generation scheme proved
very satisfactory to solve the VRPTW under tight constraints,
but did not achieve satisfactory results for the CVRP.
Therefore, until the first 2000s, the branch-and-cut approaches were
deemed to be the best approach for solving the CVRP.
In \citeyear{desrochers1992}, \citeauthor{desrochers1992} proposed the dynamic programming
based label setting algorithm.
This algorithm still constites the major core component
in modern BPC schemes to efficiently solve the pricing problem.
\textcite{kohl1999}, later generalized in \cite{desaulniers2008}, introduce the
2-paths inequalities, and were one of the first attemps to integrate
cutting-planes within the BAP framework for solving the CVRP.
One of the major breakthrough in column generation and VRP research
was obtained in \textcite{fukasawa2006}, which were the
first authors to propose a branch-and-cut-and-price (BCP) algorithm,
embedding a powerful robust-cuts based cutting-plane approach
typically found in BAC algorithms.
\citeauthor{fukasawa2006} integrated the cutting-planes proposed in \cite{lysgaard2004},
and the column generation considered only q-routes without $k$-cycles.
\textcite{fukasawa2006} was able to solve all CVRP instances up to approximately 100 customers.
Since the work of \citeauthor{fukasawa2006} until now, column generation
and the label-setting algorithm have been the defacto procedures
of modern and efficient VRP solvers.
Later, \textcite{baldacci2008}, proposed a slightly different approach w.r.t. \citeauthor{fukasawa2006}.
They employ a column generation considering elementary columns and some more inequalities.
A bounding procedure is employed to quickly
improve the dual bound while drastically reduce the number
of pricing iterations and the columns that needs consideration,
Instead of branching, they use full enumeration of the candidate
routes and solve the problem at the root node by employing a MIP solver.
\textcite{pessoa2008a} improves over the work of \citeauthor{fukasawa2006}.
\textcite{baldacci2011} proposed the ng-routes, a very effective
partial (soft) elementarity constraint
to tradeoff the elementarity condition (i.e. good dual bound in pricing)
for a simpler pricer problem.
The ng-routes can be embedded inside the label-setting algorithm, and
it is another core ingredient of modern VRP solver.
\textcite{ropke2012} revisits the work \citeauthor{fukasawa2006} and applies
the ng-routes relaxation.
\textcite{contardo2014} proposes an effective enumeration schemes and employ the ng-routes effectively,
and was able to solve CVRP instances made of 151 customers.
Finally, a modern BCP was proposed in \textcite{pecin2017}, which
proposed the non-robust limited memory subset row cuts \parencite{pecin2017a}.
By using a bidirectional label setting algorithm, a modern dual smoothing and enumeration
approach and the ng-routes relaxation, they were able to solve CVRP
instances made of 200 customers.
At the day of writing, \textcite{pessoa2020a} is the current state of the
art BCP framework based on column generation with ng-routes relaxation
for solving the CVRP problem.






\begin{comment}
\cite{jepsen_branch-and-cut_2011}

Before 1980 very few exact algorithms for cvrp and vrptw had been
proposed, but in the early 1980s two new exact methods where proposed.
From this point the history of exact methods for cvrp and vrptw can
be divided into three phases. The first phase was the introduction of the
Set Partition and the development of Branch-and-Cut-and-Price (bp) algo-
rithms using a relaxed pricing problem. The second was the development of
Branch-and-Cut (bac) algorithms. In the current phase the pricing problem
is no longer relaxed and cuts in the master problem of the Branch-and-Cut-
and-Price algorithms is used. The first two phases where started at the same
point in time and there is still development on the algorithms in the context
of cvrp and vrptw. The algorithms from these two phases are also used
on several other variants of the Vehicle Routing Problem. The third phase
was started in the middle of the 2000s and the algorithms from this phase
are currently the best overall performing algorithms.
\end{comment}

\section{Thesis Contributions}
\label{sec:intro-thesis-contributions}

One of the major problems of current state-of-the-art CVRP solvers
is that they are usually developed and tuned through the use of historical
benchmark instances.
The major historical test instances are classified in different sets (or families), and
they are usually referred in the literature through a single upper case letter.
We here summarize the core sets proposed by the operations research community for the CVRP problem:
(i) set E is proposed in \textcite{christofides1969} and contains no description about how the instances were generate,
(ii) set M is proposed in \textcite{christofides1979} and it is obtained by merging together some instances from the E set,
(iii) set F is proposed in \textcite{fisher1994} and it obtained from an actual distribution problem of groceries in the city of Ontario,
finally (iv) sets A, B, P are proposed in \textcite{augerat1995} and are generated artificially: A is random, B is clustered, P generated from A,B,E by changing capacities.
Another popular test set is the one proposed in \textcite{golden1998},
which contains large scale instances ranging from 200 to 480 customers,
generated programmatically following concentric geometric figures.

These benchmark instances suffer from being either too homogeneous, or too artificial,
while not covering the main characteristics found in current real-world application problems.
In the work of \textcite{uchoa2017}, for example, they propose
a new more modern and diverse set of benchmark instances (called set X, ranging from 100 to 1000 customers)
to replace the historical used ones, since those have become "rather easy" for modern algorithms.
Despite this recent effort in proposing new instances for the CVRP, the scientific community
has yet to fully agree on a common denominator for new more-modern benchmark set, and therefore,
the common and historical instances played (and still remains) the main central test-bed for comparing
and assessing the performance of CVRP contributions.

These historical instances are usually characterized with stringent vehicle capacities
which consequently give rise to optimal solutions characterized by small routes, each visiting few customers.
In practice, the vehicle capacity is rarely the bottleneck and
real-world modern distribution problems are instead characterized by much longer routes.
When solving the pricing problem, it has been shown that the performance of the dynamic labeling algorithm
tends to drop as the length of the routes increases,
while at the same time,
the performance of branch-and-cut algorithms seem to improve in this domain \inlinetodo{Correct? Citation needed}.

The goal of the thesis lies in studying the feasibility and competitiveness of a
branch-and-cut algorithm, implemented through a commercial MIP software package,
for solving the pricing problem.
The objective is to empirically evaluate the performance of the proposed
branch-and-cut framework against the state-of-the-art labeling
algorithm, while empirically measuring how the two frameworks behave
as the lengths of the route they need to generate increases.
\cite{jepsen2014} proposed a branch-and-cut framework for solving the pricing problem.
In their work, \citeauthor{jepsen2014} showed that, despite the dynamic programming algorithm
turned out to be much faster in many instances, the BAC framework exhibited
better performance for some larger instances; proving that
a BAC framework could complement the dynamic programming algorithm for solving the PP.
This thesis stems from the original work \citeauthor{jepsen2014}.
The objective of this thesis is to revisit the work of \citeauthor{jepsen2014},
and verify whether recent development improvements in MIP solvers
have made them competitive at solving the pricing problem,
or vice versa,
if the current situation and modern dynamic programming algorithms have
made BAC approaches completely obsolete.



\section{Outline}
\label{sec:intro-outline}

TODO: Introduce the outline of the thesis
