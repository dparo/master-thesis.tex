\chapter{Introduction}

\section{The Capacitated Vehicle Routing Problem (CVRP)}
\label{sec:intro-cvrp-problem}

The Capacitated Vehicle Routing Problem (CVRP) is a very well-known combinatorial optimization problem,
first presented in \textcite{dantzig1959},
which can be considered a generalization of the well-known Travelling Salesman Problem (TSP).
The problem consists in finding an optimal route for a delivery problem
starting from a common point called the depot,
where a homogeneous fleet composed of a fixed number of trucks, subject to capacity constraints,
need to serve customer demands.
Given as input: a weighted graph, the customer demands and the vehicle capacity,
the problem consists in minimizing the overall travel distance,
while serving all the customers exactly once.

The CVRP belongs to the wider class of problems known as the Vehicle Routing Problems (VRPs).
There are many variations of VRPs proposed in the literature such as
the Vehicle Routing Problem with Time Windows (VRPTW) and many others.
Nonetheless, CVRP remains probably the most central and studied one.
For a more complete survey of the many variations of the VRP problems refer to \cite{poggi2014}.


CVRP is usually defined more rigorously through an Integer Programming (IP) formulation.
The IP formulation is a mathematical tool which can describe combinatorial optimization problems
through the usage of constraints, usually defined with linear inequalities.
In the next section we will present the most common IP formulations for the CVRP, which
are required to understand the content of this thesis.

\section{Mathematical formulations}
\label{sec:intro-cvrp-mathematical-formulations}


In this section we define the CVRP through two very well known mathematical formulations:
the three-index flow formulation presented in \textcite{toth2002} and
the Set Partitioning (SP) formulation presented in \textcite{balinski1964}.
Despite the SP formulation being older, in later years thanks to algorithmic advances
and the development of efficient Branch \& Price frameworks, it has become the de facto
state-of-the-art core component for solving CVRP problems \parencite{pessoa2020}.

We begin the section by defining some mathematical quantities that will be used throughout
the remainder of the chapter.

\medskip

Let $G = \Tuple*{V, E}$ denote a \textbf{complete undirected network}, where $V = \Set*{0, 1, \dots, N - 1}$ denotes the set of nodes,
$E = \Set*{e = (i, j) \mid \allowbreak i,j \in V, \allowbreak  j \ge i + 1}$ the set of edges, and $N$ the number of nodes in the network.
The value $0 \in V$ is used to denote the depot node.
For convenience, we define $V_0 = V \setminus \Set*{0}$ to express the set of customers, and $N_0 = N - 1$ to denote the number of customers.
Let $\delta(S)$ with $S \subseteq V$ denote the edges crossing the set $S$ and its complement $\overline{S} = V \setminus S$.
More formally we can express $\delta(S)$ as $\delta(S) = \Set*{ (i, j) \in E \mid i \in \Expr*{S \cap V}, j \in \Expr*{ \overline{S} \cap V } }$.
For brevity, we also define $\delta(i) = \delta(\Set*{i})$ to denote the set of edges incident to node $i \in V$.

Let $q_{i} \in \R, q_{i} \ge 0$ denote the demand function, which represent the required demand that need to be served for vertex $i \in V$.
For convenience, we fix $q_0 = 0$.
Let $d_{ij} \in \R, d_{ij} > 0$ denote the distance function between a pair of nodes  $i, j \in V$.
We assume that the distance function is symmetric $d_{ij} = d_{ji}$ and satisfies the triangle inequality $d_{ij} \le d_{ih} + d_{hj}$.
Finally, given the total number of trucks $K \in \N_+$ and an upper bound $Q \in \R_+$ representing the capacity of each truck, we can finally express the CVRP problem as an Integer Programming (IP) formulation.

A feasible solution to the CVRP problem consists of $K$ tours starting from the depot node.
Each customer is visited exactly once, and the sum of the customer demands visited in each tour does not exceed the truck capacity $Q$.
An optimal solution to the CVRP is a feasible solution which minimizes the sum of the overall edge weights across all the tours.
In the remainder of the section we introduce the two most common IP mathematical formulations for the CVRP.

\subsubsection{The three-index flow formulation}
\label{sec:intro-cvrp-three-index-flow-formulation}

The three-index flow formulation, first presented in \textcite{toth2002},
is an IP model employing $O(N^2 K + N K)$ binary variables.

We define a set of binary variables $x_{ijk} \in \Set*{0, 1}, (i, j) \in E, k = 1, \dots, K$, to encode whether vehicle $k$ traverses edge $(i, j)$,
and another set of binary variables $y_{ik} \in \Set*{0, 1}, i \in V, k = 1, \dots, K$ to encode whether truck $k$ serves node $i \in V$.
We can therefore define the three-index flow formulation through an IP model as follows:

\begin{align}
	\min_{x, y} \quad z_\mt{3F}(x, y) & =  \sum_{k = 1}^K \sum_{(i, j) \in E} d_{ij} x_{ijk} \label{eq:three-index-flow-obj-func}                                                                                                                          \\
	                                  & \sum_{k = 1}^K y_{ik} = 1                                                                 & \quad \forall i \in V_0                                              \label{eq:three-index-flow-all-customers-visited} \\
	                                  & \sum_{k = 1}^K y_{0k} = K                                                                 & \label{eq:three-index-flow-tour-starts-and-ends-at-depot}                                                              \\
	                                  & \sum_{\EqStackTwo{j \in V}{(i, j) \in E}} x_{ijk} = 2 y_{ik}                              & \quad \forall i \in V,\ k = 1, \dots, K \label{eq:three-index-flow-force-visited-customer-if-flow}                     \\
	                                  & \sum_{i \in V} q_i y_{ik} \le Q                                                           & \quad \forall k = 1, \dots, K \label{eq:three-index-flow-force-resource-upper-bound}                                   \\
	                                  & \sum_{i, j \in S} x_{ijk} \le |S| - 1                                                     & \quad \EqStackTwo{\forall S \subseteq V, |S| \ge 2}{k = 1, \dots, K} \label{eq:three-index-flow-secs}                  \\
	                                  & x_{ijk}                   \in \Set*{0, 1}                                                 & \quad \forall (i, j) \in E,\ k = 1, \dots, K             \label{eq:three-index-flow-x-mip-var-bounds}                  \\
	                                  & y_{ik}                    \in \Set*{0, 1}                                                 & \quad \forall i \in V,k = 1, \dots, K  \label{eq:three-index-flow-y-mip-var-bounds}
\end{align}

where $z_\mt{3F}(x, y)$, as defined in \eqref{eq:three-index-flow-obj-func}, is the objective function to be minimized (i.e. the overall travel distance).
Constraint \eqref{eq:three-index-flow-all-customers-visited} forces all customers to be served exactly once.
Constraint \eqref{eq:three-index-flow-tour-starts-and-ends-at-depot} forces all the truck tours to start at the depot and end at the same spot.
Constraint \eqref{eq:three-index-flow-force-visited-customer-if-flow} binds the $y_{ik}$ variables to the corresponding $x_{ijk}$ variables, by ensuring that if a truck's route passes through a vertex, then the corresponding node is marked as visited.
Constraint \eqref{eq:three-index-flow-force-resource-upper-bound} is the resource upper bound contraint and it ensures that the demand served by each truck does not exceed the truck capacity.
Constraints \eqref{eq:three-index-flow-secs} are the TSP subtour elimination constraints (SECs) and are used to avoid the formation of spurious unconnected subtours.
Finally, Constraints \eqref{eq:three-index-flow-x-mip-var-bounds}, \eqref{eq:three-index-flow-y-mip-var-bounds} bound and force integrality for the IP variables.

Since the number of SECs is exponential in the number of nodes $N$, they are usually not inserted statically in the model but are generated lazily within the running time of the resolution process.

There's an important observation to be made on constraint \eqref{eq:three-index-flow-tour-starts-and-ends-at-depot}.
By using the equality sign, we're forcing solutions to use all the available $K$ trucks, even though better solutions making use of less trucks may exist.
In our case, we decided to fix the number of routes in the CVRP formulation since it seems that this is the most agreed contention in the literature.
Some authors, instead, prefer a different CVRP formulation, by not fixing the number of routes, and by essentially using a less-than-sign in place of the equality.


The three-index flow formulation is usually solved through the usage of a standard Branch \& Cut framework approach.
Modern CVRP solvers, instead, rely on a different mathematical formulation and employ a  mostly Branch \& Price based-approach (although hybridization are also possible).
The Set Partitioning (SP) formulation is the main starting point employed by Branch \& Price solvers.
In this thesis we will mostly concentrate on Branch \& Price approaches for the CVRP.
In the next subsection we will introduce the set partitioning formulation, and in the remainder of the section
we will briefly introduce the key ingredients of modern Branch \& Price solvers.

\subsubsection{The Set Partitioning (SP) formulation}
\label{sec:intro-set-partition-formulation}

The Set Partitioning (SP) integer programming formulation presented in \textcite{balinski1964},
works substantially differently from the three-index flow formulation or any other commonly employed IP formulations.
The SP formulation uses a very small number of constraints while offloading all the model complexity to an exponential number of binary variables.

The SP formulation can be viewed as a Dantzig-Wolfe reformulation \parencite{dantzig1960} of the three-index flow formulation.
Let $P = \Set*{p \mid p\ \text{is a single-truck feasible route}}$ be the set of all feasible routes,
let $\lambda_p \in \Set*{0, 1}$ be a binary variable indicating whether route $p$ is used
and finally let $a_{ijp} \in \Set*{0, 1}$ be a "static encoding" for a route $p$, i.e. if arc $(i, j) \in E$ is used by route $p$.
The main advantage of the SP model is that it can handle many constraints, since their definition are captured within the definition of the set $P$ itself.
Anyhow, we can write the full SP model as:


\begin{align}
	\min_{\lambda} \quad z_\mt{SP}(\lambda) & = \sum_{p \in P} \sum_{(i, j) \in E} d_{ij} a_{ijp} \lambda_p \label{eq:set-partitioning-obj-func}                                                                                                                                           \\
	                                        & \sum_{p \in P} \sum_{(i, j) \in \delta(i)} a_{ijp} \lambda_p = 2                                   & \quad \forall i \in V_0                                              \label{eq:set-partitioning-customers-visited-by-exactly-one-route} \\
	                                        & \sum_{p \in P} \lambda_{p} = K\label{eq:set-partitioning-K-routes}                                                                                                                                                                           \\
	                                        & \lambda_p                    \in \Set*{0, 1}                                                       & \quad \forall p \in P \label{eq:set-partitioning-lambda-mip-var-bounds}
\end{align}

where, $z_\mt{SP}(\lambda)$, as defined in \eqref{eq:set-partitioning-obj-func} is the objective function to be minimized (i.e. the overall travel distance).
Constraint \eqref{eq:set-partitioning-customers-visited-by-exactly-one-route} forces each customer to be served from a single unique route.
Constraint \eqref{eq:set-partitioning-K-routes} enforces that exactly $K$ routes are picked.
Finally, constraints \eqref{eq:set-partitioning-lambda-mip-var-bounds} are the bounding and integrality constraints for all the feasible routes.


As one may guess, due the exponential number of binary variables, the SP formulation cannot be used in as-is in practice.
However, a variant of the SP formulation can be tackled efficiently by column generation approaches embedded inside a Branch \& Price framework.
Branch \& Price frameworks and column generation have been shown to work remarkably well for solving the CVRP.

In the next sections we will introduce the Branch \& Price framework and the column generation approach, key components employed in modern state-of-the-art CVRP solvers.

\section{Resolution methods}
\label{sec:intro-resolution-methods}

\subsection{Branch and Cut}
\label{sec:intro-branch-and-cut}

\mytodo{Write this section or merge it inside the "Solving the pricing problem"}

\subsection{Branch and Price}
\label{sec:intro-branch-and-price}

Branch-and-price frameworks are in essence a branch-and-bound scheme, i.e. making use of a search tree, that originates when solving the SP formulation for vehicle routing problems.
Compared to more traditional Branch \& Cut frameworks, their primary focus is the usage of a column generation technique for improving the dual bound, see \textcite{righini2008}.
Branch and Price frameworks were first applied successfully in \textcite{gilmore1961} to the Cutting-Stock problem.

\subsubsection{Column generation and the Pricing Problem}
\label{sec:column-generation-and-pricing-problem}

The purpose of the column generation procedure is to generate routes for the SP formulation lazily on demand.
Consider the Master Problem (MP) of the set partitioning formulation defined by relaxing the integrality constraints:

\begin{align}
	\min_{\lambda} \quad z_\mt{MP}(\lambda) & = \sum_{p \in P} \sum_{(i, j) \in E} d_{ij} a_{ijp} \lambda_p \label{eq:mp-obj-func}                                                                                                                             \\
	                                        & \sum_{p \in P} \lambda_{p} = K                                                       & \label{eq:mp-K-routes}                                                                                                    \\
	                                        & \sum_{p \in P} \sum_{(i, j) \in \delta(i)} a_{ijp} \lambda_p = 2                     & \quad \forall i \in V_0                                              \label{eq:mp-customers-visited-by-exactly-one-route} \\
	                                        & 0 \le \lambda_p \le 1                                                                & \quad \forall p \in P \label{eq:mp-lambda-mip-var-bounds}
\end{align}


When solving the MP, at each iteration of the simplex algorithm we seek for a non-basic variable (i.e. column) to price out and enter the basis.
This is achieved by evaluating the dual variables $\pi \in \R$ associated with constraints \eqref{eq:mp-K-routes}, \eqref{eq:mp-customers-visited-by-exactly-one-route}.
Due to the huge size of the set of routes $P$, it is computationally intractable to evaluate numerically the dual variables $\pi \in \R$.

\medskip

Therefore, a valid approach taken by Branch \& Price framework consists of considering only a small subset of columns $\mc{P} \subseteq P$, obtainining the following linear program relaxation:

\begin{align}
	\min_{\lambda} \quad z_\mt{RMP}(\lambda) & = \sum_{p \in \mc{P}} \sum_{(i, j) \in E} d_{ij} a_{ijp} \lambda_p \label{eq:rmp-obj-func}                                                                                                                              \\
	                                         & \sum_{p \in \mc{P}} \lambda_{p} = K                                                        & \label{eq:rmp-K-routes}                                                                                                    \\
	                                         & \sum_{p \in \mc{P}} \sum_{(i, j) \in \delta(i)} a_{ijp} \lambda_p = 2                      & \quad \forall i \in V_0                                              \label{eq:rmp-customers-visited-by-exactly-one-route} \\
	                                         & 0 \le \lambda_p \le 1                                                                      & \quad \forall p \in \mc{P} \label{eq:rmp-lambda-mip-var-bounds}
\end{align}

which takes the name of Restricted Master Problem (RMP).

In BAP frameworks, we seek to solve the so-called pricing problem (PP) defined as:

\begin{equation}
	{c^\star_p} = \min_{p \in P} \Set*{ \bar{c_p} = \sum_{(i, j) \in E} \Expr*{d_{ij} - \frac{\pi_i + \pi_j}{2}} a_{ijp}  }
\end{equation}

where $\bar{c_p}$ denotes the reduced cost of a route $p \in P$, and $c^\star_p$ is the reduced cost of the optimal route $p^\star \in P$ that leads to the best dual bound improvement.
Any $p \in P$ which satisfies $\bar{c_p} < 0$ is a valid column which can enter the basis of the RMP.
The Branch \& Price solver needs to smartly manage the set $\mc{P} \subseteq P$, which stores in a pool.
It is responsibility of the BAP framework to efficiently manage which routes to preserve or drop within the pool during the running time of the resolution process.

The resolution method, or algorithm, used to solve the PP is usually called "oracle" in the literature.
The oracle needs to solve the pricing problem which, due to the definition of the set $P$, coincides with solving an Elementary Shortest Path Problem with Resource Constraints (ESPPRC) over a directed graph with weights $\hat{c_{ij}} = d_{ij} - \frac{1}{2} \pi_i - \frac{1}{2} \pi_j$, where the source and sink vertex collapse at the depot node.

Note that, the BAP solver need not to solve the PP optimally at each iteration of the simplex algorithm.
To improve the dual bound, it is usually enough to find any $p \in P$ achieving $\bar{c_p} < 0$, which allow the usage of heuristic algorithms especially during the very first few iterations, where finding good reduced cost columns is surprisingly easy.
Branching occurs when either: (i) the optimal solution of the PP, $p^\star$, achieves $c^\star_p \ge 0$ (non-negative solution) and $\exists p \in \mc{P} \mid \lambda_p \notin \Set*{0, 1}$; (ii) the column generation procedure tails off, i.e. the gained dual bound improvements compared to the running time to generate a column become suboptimal.



\subsection{Branching and Cut Generation within BAP frameworks}
\label{sec:intro-branching-and-cut-generation-within-bap-frameworks}

In order to satisfy the integrality constraints for the SP formulation, solving the RMP at the root node
is almost always not enough.
Therefore, a search-tree and a branching scheme is employed to seek for the optimal integral solution $\lambda^\star_p \in \Set*{0, 1} \quad \forall p \in P$.
Although non strictly-necessary, modern BAP also use cut generation procedures to efficiently improve the dual bound and improve convergence speed.
Modern BAP frameworks are in fact a hybridization between a BAP and a BAC framework, making them a Branch \& Cut \& Price (BCP) frameworks.

\medskip

Unfortunately, branching and cut generation in BCP frameworks is more delicate compared to more traditional BAC frameworks due to the presence of the pricing problem.
Depending on the branching and cut generation schemes employed, two classes of inequalities are possible: \textbf{robust} versus \textbf{non-robust} inequalities.

A \textbf{robust} inequality is an inequality which can be safely added to the RMP without altering the structure of the set of feasible paths $P$.
That is, robust inequalities do not require explicit modeling in the PP formulation and instead manifest their contribution directly in the dual variables $\pi$.
An oracle, therefore, after the introduction of a robust inequality in the RMP, needs to solve the same ESPPRC problem but with slightly different weights associated on each edge.

A \textbf{non-robust} inequality, instead, is much harder to handle since it changes the structure of the set of feasible paths $P$.
Non-robust inequalities may in general be quite strong but, unfortunately, require explicit modeling and support within the oracle.
These types of inequalities can drastically complicate the pricing problem, trading better dual improvements for increased column generation times.
Therefore, their usage must be assessed on a case-by-case basis.


In this thesis we will mostly concentrate on branching and cut generation schemes which make use of \textbf{robust} inequalities.

\subsection{Solving the Pricing Problem}
\label{sec:intro-solving-the-pricing-problem}

\mytodo{Write this section or merge it}

The label-setting algorithm work by label construction and propagation from node to node.
The dominance rules in the label-setting algorithm allows the oracle
to efficiently prune the search space by ignoring dominated labels.

In order to simplify the pricing problem further,
some authors started to propose to relax the elementarity condition
to speed up the convergence of the label-setting algorithm, worsening however, the dual improvement.
It is in fact possible to drop the elementarity constraints, only if, the BAP framework supports
branching on the edges of the original three-index flow formulation.
Notable contributions in relaxing the elementarity constraints include:
(i) the q-route relaxation suggested in \textcite{christofides1981},
(ii) a state-space relaxation procedure suggested in \textcite{christofides1981a},
(iii) shortest path relaxation suggested in \textcite{desrosiers1984}.


\section{Literature Review}
\label{sec:intro-literature-review}

\mytodo{Write this section, by integrating the literature as I read it}

One of the very first few attempts, in solving the CVRP, were based on branch-and-cut algorithms
which at that time had historical prevalence.
Some notable BAC contributions are provided in the works of
\textcite{araqueg1994}, \textcite{augerat1995}, \textcite{blasum2000}, \textcite{achuthan2003}, \textcite{ralphs2003}, \textcite{lysgaard2004},
These works showed that CVRP instances, even with small number of customers (less than 100) proved
to be very challenging for the BAC approaches.

Then, \textcite{fukasawa2006} solved all CVRP instances up to approximately 100 customers
using a branch-cut-and-price approach.
Later, the works of \textcite{baldacci2008}, \textcite{baldacci2011}
improved the overall running times by employing a column and cut generation scheme.
Later, \textcite{contardo2014} was able to solve a CVRP instance made of 151 (M-n151-k12).
Later, \textcite{pecin2017} solved CVRP instances made of 200 customers (M-n200-k16, M-n200-k7).

\begin{comment}
\cite{jepsen_branch-and-cut_2011}

Before 1980 very few exact algorithms for cvrp and vrptw had been
proposed, but in the early 1980s two new exact methods where proposed.
From this point the history of exact methods for cvrp and vrptw can
be divided into three phases. The first phase was the introduction of the
Set Partition and the development of Branch-and-Cut-and-Price (bp) algo-
rithms using a relaxed pricing problem. The second was the development of
Branch-and-Cut (bac) algorithms. In the current phase the pricing problem
is no longer relaxed and cuts in the master problem of the Branch-and-Cut-
and-Price algorithms is used. The first two phases where started at the same
point in time and there is still development on the algorithms in the context
of cvrp and vrptw. The algorithms from these two phases are also used
on several other variants of the Vehicle Routing Problem. The third phase
was started in the middle of the 2000s and the algorithms from this phase
are currently the best overall performing algorithms.
\end{comment}

\section{Thesis Contributions}
\label{sec:intro-thesis-contributions}

One of the major problems of current state-of-the-art CVRP solvers
is that they are usually developed and tuned through the use of historical
benchmark instances.
The major historical test instances are classified in different sets (or families), and
they are usually referred in the literature through a single upper case letter.
We here summarize the core sets proposed by the operations research community for the CVRP problem:
(i) set E is proposed in \textcite{christofides1969} and contains no description about how the instances were generate,
(ii) set M is proposed in \textcite{christofides1979} and it is obtained by merging together some instances from the E set,
(iii) set F is proposed in \textcite{fisher1994} and it obtained from an actual distribution problem of groceries in the city of Ontario,
finally (iv) sets A, B, P are proposed in \textcite{augerat1995} and are generated artificially: A is random, B is clustered, P generated from A,B,E by changing capacities.
Another popular test set is the one proposed in \textcite{golden1998},
which contains large scale instances ranging from 200 to 480 customers,
generated programmatically following concentric geometric figures.

These benchmark instances suffer from being either too homogeneous, or too artificial,
while not covering the main characteristics found in current real-world application problems.
In the work of \textcite{uchoa2017}, for example, they propose
a new more modern and diverse set of benchmark instances (called set X, ranging from 100 to 1000 customers)
to replace the historical used ones, since those have become "rather easy" for modern algorithms.
Despite this recent effort in proposing new instances for the CVRP, the scientific community
has yet to fully agree on a common denominator for new more-modern benchmark set, and therefore,
the common and historical instances played (and still remains) the main central test-bed for comparing
and assessing the performance of CVRP contributions.

These historical instances are usually characterized with stringent vehicle capacities
which consequently give rise to optimal solutions characterized by small routes, each visiting few customers.
In practice, the vehicle capacity is rarely the bottleneck and
real-world modern distribution problems are instead characterized by much longer routes.
When solving the pricing problem, it \todo{Citation needed} has been shown that the performance of the dynamic labeling algorithm
tends to drop as the length of the routes increases,
while at the same time,
the performance of branch-and-cut algorithms seem to improve in this domain.

The goal of the thesis lies in studying the feasibility and competitiveness of a
branch-and-cut algorithm, implemented through a commercial MIP software package,
for solving the pricing problem.
The objective is to empirically evaluate the performance of the proposed
branch-and-cut framework against the state-of-the-art labeling
algorithm, while empirically measuring how the two frameworks behave
as the lengths of the route they need to generate increases.
\cite{jepsen2014} proposed a branch-and-cut framework for solving the pricing problem.
In their work, \citeauthor{jepsen2014} showed that, despite the dynamic programming algorithm
turned out to be much faster in many instances, the BAC framework exhibited
better performance for some larger instances; proving that
a BAC framework could complement the dynamic programming algorithm for solving the PP.
This thesis stems from the original work \citeauthor{jepsen2014}.
The objective of this thesis is to revisit the work of \citeauthor{jepsen2014},
and verify whether recent development improvements in MIP solvers
have made them competitive at solving the pricing problem,
or vice versa,
if the current situation and modern dynamic programming algorithms have
made BAC approaches completely obsolete.



\section{Outline}
\label{sec:intro-outline}

TODO: Introduce the outline of the thesis
