\chapter{\bapcod\ Parametrization}
\label{sec:bapcod-appendix}

This section lists exhaustively all the \bapcod\ and VRPSolver extension
parameters that were employed  to obtain the results of \Cref{sec:results}.
We will not provide a full exhaustive list of all the possible parameters,
instead, we will mainly concentrate on the main ones that were necessary to achieve
the desired intent.
The \bapcod\ technical report \textcite{sadykov2021} provides a more
comprehensive list and describes the parameters in more depth.
The technical report alone is not enough to fully comprehend the purpose of each parameter,
therefore it is highly suggested to first read the scientific document of \textcite{pessoa2020a}.

\medskip

In the next section we will introduce the parameters that we've used, along
with: associated values, meaning and justification for their usage.
We want to provide a brief summary of why and how these parameters were set.
Non-robust branching and non-robust cut-generation
must be necessarily disabled as our pricer do not support those.
While it is technically possible to enable robust branching and cut-generation,
we instead opted to disable these two features entirely.
To stress the labeling algorithm it is simply enough to evaluate
the column generation iterations issued at the root node of branch-and-bound tree
free of additional cutting-planes.
The ng-sets augmentation is enabled and the ng-set maximum
set size is raised as high as possible.
On top of that, the tailing off condition for the VRPSolver pricer was disabled.
This is done to stress as much as possible the pricer to produce
dual bounds as close as possible to the elementary bound, and to
improve the obtained dual bound at the end of the root node of the search-tree.
The labeling algorithm of the VRPSolver extension is able to produce multiple
routes per pricing iteration as to feed the BPC with more diversified paths.
Since our pricer always outputs a single column (the optimal column),
we've disabled such feature to yield a fair comparison.

\section{Misc parameters}
These parameters are used to control various miscellaneous aspects of \bapcod,
such as the logging verbosity.
They have limited importance, but can be quite useful for debugging purposes
and for understanding what's going within the guts of the BPC algorithm.

\begin{itemize}
	\item \texttt{DEFAULTPRINTLEVEL = 0}.
	      Controls the verbosity of the logging system of \bapcod\ by setting it to a relatively quiet level.
	      This value achieves a good trade off between the amount of information which is emitted
	      and the amount of characters printed per second.
	\item \texttt{printMasterPrimalSols = 2}.
	      By setting this parameter to 2, \bapcod\ will print the fractional solution after each column generation convergence.
	      Useful for debugging.
\end{itemize}

\section{Core parameters}
These parameters are used to control the general behavior of the BPC algorithm,
such as total running time, which pricer to use, enabling specific
components and performing validation checks.

\begin{itemize}
	\item \texttt{GlobalTimeLimit = 3600}.
	      Sets the maximum allowed solving time to one hour.
	      This timelimit is global and it affects the whole BPC algorithm, from the starting
	      to the resolution process at the root node until an integral optimal solution is found.
	\item \texttt{colGenSubProbSolMode = 3}.
	      Tells \bapcod\ to use the custom user-provided pricing functor.
	      In our case, the pricing functor is a stubbed implementation which wraps the original VRPSolver extension pricing functor
	      and times it (see previous discussions in \Cref{sec:results-evaluation-method}).
	      By instead, setting this parameter to the value \texttt{2},
	      it is possible to tell \bapcod\ to use the default generic MIP pricer to solve the sub-problems.
	\item \texttt{ApplyPreprocessing = true}.
	      Tells \bapcod\ to apply pre-processing to adjust bounds and remove redundant constraints.
	      Since this feature can improve the model without altering the pricing sub-problem,
	      it is left enabled.
	\item \texttt{PreprocessVariablesLocalBounds = false}.
	      Prevents \bapcod\ from changing the variable bounds of sub-problems after pre-processing.
	      Since our pricer does not support changing the bounds of the variables,
	      we disable this feature.
	\item \texttt{CheckSpOracleFeasibility = false}.
	      This feature can be used for debugging and can be useful when developing custom pricing functors.
	      When this parameter is set to true, it allows to use an expensive MIP resolution process
	      to verify the correctness of the pricer algorithm.
	      The MIP is employed to check whether the produced columns satisfy all the master problem constraints.
	      In our case it is disabled.
	\item \texttt{CheckOracleOptimality = false}.
	      Similar to the \texttt{CheckSpOracleFeasibility} parameter, but also verifies the optimality of the generated columns.
\end{itemize}

\section{Column Generation parameters}

These parameters control the column generation framework.

\begin{itemize}
	\item \texttt{GenerateProperColumns = false}.
	      When this parameter is set to true, \bapcod\ will error-out if the pricer produces any non-proper column,
	      i.e. a column dishonoring the sub-problem variable bounds.
	      In our case we set this parameter to false,
	      because from our experiments it didn't seem to cooperate with the VRPSolver pricing functor.
	\item \texttt{MaxNbOfStagesInColGenProcedure = 3}.
	      Sets the number of stages the pricer is allowed to use.
	      When the stage iteration is greater than 1, the pricer is allowed to use
	      progressively lighter heuristics for determining columns.
	      When the stage iteration reaches stage 0, the pricing problem should be solved exactly.
	      \bapcod\ automatically switches to a lower stage when the previous stage converges (i.e. fails to find any reduced cost column).
	      The technical document suggests to set this parameter to $3$ when the VRPSolver extension is in use.
	      The VRPSolver extension implements two heuristic stages by using a modification of the bidirectional label setting algorithm,
	      see the \textit{Pricing heuristics} and \textit{Column and cut generation} sections of \textcite{sadykov2021a}.
	\item \texttt{ReducedCostFixingThreshold = 0.0}.
	      Tells \bapcod\ to not apply reduced cost fixing.
\end{itemize}

\section{Cut Generation parameters}
These parameters control the cutting-planes and their generation.
We've opted to completely disable cut generation.

\begin{itemize}
	\item \texttt{MasterCuttingPlanesDepthLimit = -1}.
	      When this parameter is set to $-1$, it disables cut generation of core cuts
	      (i.e. the cuts natively supported within the BPC framework).
	      The cut generation of user-defined cuts
	      is not effected by this parameter, and therefore these kinds of cuts must be disabled manually.
	      Explicit usage of user-defined cuts must be explicitly requested for usage
	      by registering the associated functors.
	      We don't explicitly register any user-defined cut in the implemented model.
	      As a natural consequence all cutting-planes are disabled, including the separation of the RCC inequalities of \cref{eq:two-index-flow-ccc}.
	\item \texttt{MaxNbOfCutGeneratedAtEachIter = 0}.
	      Sets the maximum number of core cuts added per cut round to $0$,
	      effectively further enforcing the deactivation of the core cuts generation.
\end{itemize}

\section{Branching parameters}
These parameters control the branching scheme and branching priorities performed by the BPC algorithm.
We've opted to completely disabled any form of branching.

\begin{itemize}
	\item \texttt{StrongBranchingPhaseOne=""}, \texttt{StrongBranchingPhaseTwo=""}, \texttt{StrongBranchingPhaseThree=""}, \texttt{StrongBranchingPhaseFour=""}
	      These parameters control the strong branching behaviour of \bapcod\, which is composed of multiple phases.
	      By setting each parameter to the empty string, we effectively disable strong branching for each phase.
	\item \texttt{SimplifiedStrongBranchingParameterisation = false}.
	      When this parameter is set to true, \bapcod\ populates the parameters \texttt{StrongBranchingPhaseOne}, \texttt{StrongBranchingPhaseTwo}, \texttt{StrongBranchingPhaseThree}, \texttt{StrongBranchingPhaseFour}
	      with sane default values, thus effectively enabling branching.
	      Since populating these parameters would effectively re-enable branching, we set \texttt{SimplifiedStrongBranchingParameterisation} to false.
\end{itemize}

\section{VRPSolver extension parameters}

These parameters affect the labeling algorithm, the ng-sets size,
the route enumeration procedure and some other minor aspects of the VRPSolver extension.
We recall that the VRPSolver extension was introduced in \textcite{pessoa2020a},
where it became one of the state-of-the-art approaches for tackling routing-like problems.

\begin{itemize}
	\item \texttt{RCSPuseBidirectionalSearch = 2}.
	      This parameter, referred as $\phi^\mt{bidir}$ in the scientific paper,
	      tells the RCSP pricer to use the bidirectional search for solving the pricing problem.
	\item \texttt{RCSPapplyReducedCostFixing = 1}.
	      This parameter, reffered as $\phi^\mt{elim}$ in the scientific paper,
	      tells the pricer to employ the default standard bucket arc elimination discussed in \textcite{sadykov2021a}.
	\item \texttt{RCSPmaxNumOfColsPerExactIteration = 1}, \texttt{RCSPmaxNumOfColsPerIteration = 1}.
	      These parameters, reffered respectively as $\gamma^\mt{exact}, \gamma^\mt{heur}$ in the scientific paper,
	      control the number of generated columns per iteration by the pricer respectively
	      for the heuristic stages
	      and for the exact stage.
	      Since our pricer is able to produce a single column per pricing iteration, in order to achieve a fair comparison,
	      we set the label setting algorithm to always generate a single route per pricing iteration.
	\item \texttt{RCSPallowRoutesWithSameVerticesSet = false}.
	      This parameter tells the labeling algorithm whether outputting multiple routes passing the same set of vertices are allowed.
	      When disabled,
	      it can allow the pricer to generate a more diverse set of routes
	      at the cost of increasing the pricing running time.
	      Since we're forcing the labeling algorithm to generate a single route regardless, this parameter should have no effect.
	\item \texttt{RCSPmaxNumOfEnumSolutionsForMIP = 1}.
	      This parameter, referred as $\omega^\mt{MIP}$ in the scientific paper,
	      controls the route enumeration threshold \parencite{baldacci2008},
	      at which the number of enumerated paths can trigger a direct solve of the SP formulation through a MIP.
	      Since we are interested in measuring the pricing complexity, it makes sense to disable the route enumeration feature.
	      We can disable such feature by setting the corresponding parameter to $1$.
	\item \texttt{RCSPstopCutGenTimeThresholdInPricing = 1e21}, \texttt{RCSPhardTimeThresholdInPricing = 1e21}.
	      These parameters, referred respectively as $\tau^\mt{soft}, \tau^\mt{hard}$ in the scientific paper,
	      control respectively the soft and hard time threshold for the exact pricing stage.
	      These thresholds impact the tailing-off condition of the pricer, namely, if the running time of the pricer exceeds one of these thresholds, column generation is preemptively interrupted in favor of cut generation or branching.
	      We're interested in measuring the performance of the label setting algorithm even when it is struggling, therefore we set those parameters to high values to disable the tailing off condition.
	\item \texttt{RCSPdynamicNGmode = 1}.
	      This parameter tells BapCod to scale dynamically
	      the ng-sets size based on the
	      fractional solution obtained by the column generation
	      and not based on the solution received from the pricing problem.
	      See \textcite{pessoa2020a} for more details.
	\item \texttt{RCSPinitNGneighbourhoodSize = 8}, \texttt{RCSPmaxNGneighbourhoodSize = 63}.
	      These parameters, referred respectively as $\eta^\mt{init}, \eta^\mt{max}$ in the scientific paper,
	      sets the bounds in which the ng-set size can be dynamically extended.
	      Raising $\eta^\mt{init}$ can improve the dual bound generated from the pricer, but usually leads to explosion of computation times, especially if it is raised a lot.
	      Therefore keeping $\eta^\mt{init}$ small and raising $\eta^\mt{max}$ is instead the preferred approach if one seeks to improve the dual bound at each branch-and-bound node.
	      The ng-sets size starts at the lower value $\eta^\mt{init}$ and it is later increased (if param \texttt{RCSPdynamicNGmode} is enabled)
	      after the column generation convergence and only if the MP contains a fractional solution (see \cite{pessoa2020a}).
	      Since our pricer produces the best dual bound improvement possible (elementary routes),
	      we want to stress the labeling algorithm to try as hard as possible to achieve
	      reasonable dual bounds.
	      Therefore, by setting $\eta^\mt{init} = 8$ and $\eta^\mt{max} = 63$
	      we force the labeling algorithm to produce better dual bounds towards the end of the column generation convergence.
	      Note that, due to \bapcod's implementation details $\eta^\mt{max} \le 63$ and thus
	      elementary routes can be guaranteed in the column generation
	      only for instances having less than $64$ nodes.
	\item \texttt{RCSPmaxNGaverNeighbourhoodSize = 63}.
	      This parameter is very similar to the $\eta^\mt{max}$ parameter, but for the average case.
	      In our case we set this parameter to the same value of $\eta^\mt{max}$
	      as it was suggested from Ruslan Sadykov,
	      a researcher who worked on \bapcod\ and VRPSolver extension implementations.
	\item \texttt{CutTailingOffThreshold = 0.0000001}, \texttt{CutTailingOffCounterThreshold = 999999}.
	      These parameters, referred respectively as $\delta^\mt{gap}, \delta^\mt{num}$ in the scientific paper,
	      control the tailing off condition of cut-separation, i.e. the threshold
	      at which the BPC deems cuts ineffective and switches to lower priority
	      (and usually more computationally expensive) cuts.
	      Despite their name and their application to cut separation, these two important
	      parameters also affect the column generation procedure, specifically the augmentation of the ng-sets.
	      As pointed out in the original paper,
	      increasing the ng-sets size can be seen as a form of "cut generation"
	      since it improves the dual bound.
	      Ng-sets augmentation have the highest priority, followed by cut-generation and branching in this order.
	      Since we always prefer to augment the ng-sets as much as possible we want
	      to disable the cut-tailing off condition.
	      We can disable the cut-tailing off condition by setting these parameters to the above values.
\end{itemize}

\begin{comment}
[ About what is reduced cost fixing ]
[ Bucket arc elimination procedure = Reduced cost fixing procedure]
\textcite{sadykov2021}
VRPSolver extension includes an implementation of the pricing functor which
allows the user to define the subproblems as resource constrained shortest path
problems in graphs. The functor implements the bucket-graph based labeling
algorithm from paper [16] for solving the pricing problem, as well as the corre-
sponding bucket arc elimination procedure (i.e. reduced cost fixing procedure),
and the elementary route enumeration procedure [1]. VRPSolver extension also
implements cut separation functors for rounded cap
\end{comment}
