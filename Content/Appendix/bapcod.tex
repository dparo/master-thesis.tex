\chapter{\bapcod}
\label{sec:bapcod-appendix}

\mytodo{Introduce what is BapCod, specify the version, point to the website, academic license, RCSP lib solver, etc...}

% \section{Model}
%
% \mytodo{Write the BapCod model here}
%
% \mytodo{Point out that general branching and general cuts are disabled in BapCod}
%
% \mytodo{Note that specific ESPPRC type of non-robust branching\&cuts are disabled in the BapCod model}

\section{Dual values extraction}

\mytodo{Talk about how we extract the dual values from the BapCod model reduced cost variables}

\section{Employed \bapcod\ Parametrization}
\label{sec:employed-bapcod-parametrization}

This section lists more exhaustively all the \bapcod\ parameters
that were employed to obtain the results of this thesis.
The parameters' names and their meaning are described in the technical report of \textcite{sadykov2021}.
We will not cover all the parameters in this section,
we will concentrate on the most important ones only.
The technical report alone is not enough to fully comprehend what each parameter do,
therefore it is highly suggested to first read the scientific document of \textcite{pessoa2020a},
where \bapcod\ and its VRPSolver extension were employed to solve many VRP instances.

\subsection{Core parameters}

These parameters are used to control the general behavior of \bapcod.

\begin{itemize}
	\item Controlling the logging verbosity:
	      \begin{itemize}
		      \item \texttt{DEFAULTPRINTLEVEL = 0}.
		            Controls the verbosity of the logging system of \bapcod\ by setting it to a relatively quiet level.
		      \item \texttt{printMasterPrimalSols = 2}.
		            By setting this parameter to 2, \bapcod\ will print the fractional solution after each column generation convergence.
	      \end{itemize}

	\item Controlling the runtime:
	      \begin{itemize}
		      \item \texttt{GlobalTimeLimit = 3600}. Sets the maximum allowed solving time to one hour.
		      \item \texttt{colGenSubProbSolMode = 3}. Tells \bapcod\ to use the custom user-provided pricing functor.
		            In our case, the pricing functor is a stubbed implementation which wraps the original VRPSolver extension pricing functor
		            and times it.
		            By setting such parameters to other values, it is possible to tell \bapcod\ to use a default generic MIP solver to solve the sub-problems.
		      \item \texttt{ApplyPreprocessing = true}. Tells \bapcod, to apply pre-processing to adjust bounds and remove redundant constraints.
		      \item \texttt{PreprocessVariablesLocalBounds = false}.
		            Prevents \bapcod\ from changing the variable bounds of sub-problems after pre-processing.
		            Since our pricer does not support changing the bounds of the variables,
		            we disable this feature.
		      \item \texttt{CheckSpOracleFeasibility = false}.
		            This feature is useful for debuggingg when developing custom pricing functors.
		            When this parameter is set to true, it allows to use an expensive MIP resolution process
		            to verify the correctness of the pricer algorithm.
		            The MIP is employed to check whether the produced columns satisfy all the master problem constraints.
		            In our case it is disabled.
		      \item \texttt{CheckOracleOptimality = false}.
		            Similar to the \texttt{CheckSpOracleFeasibility} parameter, but also verifies the optimality of the generated columns.
	      \end{itemize}

	\item Controlling the column generation procedure:
	      \begin{itemize}
		      \item \texttt{GenerateProperColumns = false}.
		            When this parameter is set to true, \bapcod\ will error-out if the pricer produces any non-proper column,
		            i.e. a column not respecting the sub-problem variable bounds.
		            In our case we set this parameter to false, because from our experiments it didn't seem to coope correctly with the VRPSolver pricing functor.
		      \item \texttt{MaxNbOfStagesInColGenProcedure = 3}.
		            Sets the number of stages the VRPSolver pricing functor can use.
		            When the stage iteration is greater than 1, the RCSP pricer is allowed to use
		            progressively faster (but less exhaustive) heuristics for determining columns.
		            When the stage iteration reaches stage 0, the RCSP pricer solves the pricing problem exactly.
		            \bapcod\ switches to a lower stage, when the previous stage converges (i.e. fails to find any reduced cost column).
		      \item \texttt{ReducedCostFixingThreshold = 0.0}.
		            Tells \bapcod\ to not apply reduced cost fixing.
	      \end{itemize}

	\item Controlling the cut generation:
	      \begin{itemize}
		      \item \texttt{MasterCuttingPlanesDepthLimit = -1}.
		            When this parameter is set to $-1$, it disables cut generation of core cuts
		            (i.e. the for generic cuts supported within the BPC framework).
		            Cut generation for user-defined extensions, if any, is not effected by this parameter,
		            and it must therefore be disabled manually.
		      \item \texttt{MaxNbOfCutGeneratedAtEachIter = 0}.
		            Sets the maximum number of core cuts added per cut round to $0$,
		            effectively further enforcing the deactivation of the core cut generation.
	      \end{itemize}

	\item Controlling the branching procedure:
	      \begin{itemize}
		      \item \texttt{StrongBranchingPhaseOne}, \texttt{StrongBranchingPhaseTwo}, \texttt{StrongBranchingPhaseThree}, \texttt{StrongBranchingPhaseFour} controls parameters determining how strong branching is performed for each of the phases.
		            When set to empty strings, e.g. \texttt{StrongBranchingPhaseOne=""}, disables branching for the corresponding phase.
		      \item \texttt{SimplifiedStrongBranchingParameterisation = false} if set to true, allows BapCod to perform strong branching by populating parameters \texttt{StrongBranchingPhaseOne}, \texttt{StrongBranchingPhaseTwo}, \texttt{StrongBranchingPhaseThree}, \texttt{StrongBranchingPhaseFour} to sane defaults.
	      \end{itemize}

	\item Controlling the RCSP dynamic programming labeling pricer:
	      \begin{itemize}
		      \item \texttt{RCSPuseBidirectionalSearch = 2}, called $\phi^\mt{bidir}$ in the original paper, tells the RCSP pricer whether to use the bidirectional search for solving the pricing problem
		      \item \texttt{RCSPapplyReducedCostFixing = 1}, called $\phi^\mt{elim}$ in the original paper, controls the bucket arc elimination procedure the labeling algorithm uses.
		      \item \texttt{RCSPmaxNumOfColsPerExactIteration = 1}, \texttt{RCSPmaxNumOfColsPerIteration = 1},
		            called $\gamma^\mt{exact}, \gamma^\mt{heur}$ in the original paper,
		            controls how many path solutions the pricer generates per pricer iteration respectively in the heuristic phase or in the exact phase.
		            We force the RCSP pricer to generate a single path per pricing iteration.
		      \item \texttt{RCSPallowRoutesWithSameVerticesSet = false} controls whether multiple paths which pass by the same set of vertices are allowed.
		            Shouldn't matter since we are forcing to generate a single path per pricing iteration.
		      \item \texttt{RCSPmaxNumOfEnumSolutionsForMIP = 1}, called $\omega^\mt{MIP}$ in the original paper, controls the threshold at which the number of enumerated path to trigger the solving through a MIP.
		            By setting the parameter to $1$ we are essentially disabling this feature.
		      \item \texttt{RCSPstopCutGenTimeThresholdInPricing = 1e21}, \texttt{RCSPhardTimeThresholdInPricing = 1e21}, called $\tau^\mt{soft}, \tau^\mt{hard}$ in the original paper, controls respectively the soft and hard time threshold for the pricing algorithm.
		            This thresholds control a premature ending of the pricing algorithm in favour of cut generation or branching, if the running time increases above one of these thresholds.
		            Since we want to measure the running time of the algorithm, even when it performs poorly, and we are not interested in generating cuts and branching, we increase these thresholds as high as possible.
		      \item \texttt{RCSPdynamicNGmode = 1} tells BapCod to scale dynamically the ng-sets based on the fractional solution obtained by the column generation (not based on the solution received from the pricing problem).
		      \item \texttt{RCSPinitNGneighbourhoodSize = 8}, \texttt{RCSPmaxNGneighbourhoodSize = 63}, called $\eta^\mt{init}, \eta^\mt{max}$ in the original paper, sets a "soft" elementary constraints that can dynamically be adjusted within the $\eta^\mt{init}, \eta^\mt{max}$ parameters.
		            Raising $\eta^\mt{init}$ can improve the dual bound generated from the pricer, but usually leads to explosion of computation times, especially if it is raised a lot.
		            Raising $\eta^\mt{max}$ can allow the ng-sets to reach higher values, thus improving the dual bound.
		      \item \texttt{RCSPmaxNGaverNeighbourhoodSize = 63}, very similar to parameter $\eta^\mt{max}$, but for the average case.
		            In our case we set this parameter to the same value of $\eta^\mt{max}$.
		      \item \texttt{CutTailingOffThreshold = 0.0000001}, \texttt{CutTailingOffCounterThreshold = 999999}, named $\delta^\mt{gap}, \delta^\mt{num}$ in the original paper, controls the tailing off condition at which BapCod deems cuts ineffective and switches to lower priority (usually more computationally expensive) cuts.
		            Despite their name, these two parameters also affect the pricing algorithm.
		            As pointed out in the original paper, increasing the ng-sets can be seen as a form of "cut generation" since it improves the dual bound.
		            Since we are not interested in cut generation, and we want BapCod to always prefer augmenting the ng-sets, we disable the tailing off condition.
	      \end{itemize}
\end{itemize}
