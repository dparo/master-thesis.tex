\chapter{\bapcod}
\label{sec:bapcod-appendix}

\mytodo{Introduce what is BapCod, specify the version, point to the website, academic license, RCSP lib solver, etc...}

% \section{Model}
%
% \mytodo{Write the BapCod model here}
%
% \mytodo{Point out that general branching and general cuts are disabled in BapCod}
%
% \mytodo{Note that specific ESPPRC type of non-robust branching\&cuts are disabled in the BapCod model}

\section{Dual values extraction}

\mytodo{Talk about how we extract the dual values from the BapCod model reduced cost variables}

\section{Employed \bapcod\ Parametrization}
\label{sec:employed-bapcod-parametrization}

This section lists more exhaustively all the \bapcod\ parameters
that were employed to obtain the results of this thesis.
The parameters' names and their meaning are described in the technical report of \textcite{sadykov2021}.
We will not cover all the parameters in this section,
we will concentrate on the most important ones only.
The technical report alone is not enough to fully comprehend what each parameter do,
therefore it is highly suggested to first read the scientific document of \textcite{pessoa2020a},
where \bapcod\ and its VRPSolver extension were employed to solve many VRP instances.

\subsection{Core parameters}

These parameters are used to control the general behavior of \bapcod.

\begin{itemize}
	\item Controlling the logging verbosity:
	      \begin{itemize}
		      \item \texttt{DEFAULTPRINTLEVEL = 0}.
		            Controls the verbosity of the logging system of \bapcod\ by setting it to a relatively quiet level.
		      \item \texttt{printMasterPrimalSols = 2}.
		            By setting this parameter to 2, \bapcod\ will print the fractional solution after each column generation convergence.
	      \end{itemize}

	\item Controlling the runtime:
	      \begin{itemize}
		      \item \texttt{GlobalTimeLimit = 3600}. Sets the maximum allowed solving time to one hour.
		      \item \texttt{colGenSubProbSolMode = 3}. Tell \bapcod\ to use the custom defined user-provided pricing functor.
		            In our case, in the code that we've implemented, we attach the VRPSolver pricing functor to solve the sub-problems,
		            and thus we let know \bapcod, that it should use such functor.
		            Recall that \bapcod, by default, also supports the usage of MIP solvers to tackle the sub-problems.
		      \item \texttt{ApplyPreprocessing = true}. Tells \bapcod, to apply pre-processing to adjust bounds and remove redundant constraints.
		      \item \texttt{PreprocessVariablesLocalBounds = false}.
		            Prevents \bapcod\ from changing the variable bounds of sub-problems after pre-processing.
		            Since our pricer does not support changing the bounds of the variables,
		            we disable this feature.
		      \item \texttt{CheckSpOracleFeasibility = false} allows to use a MIP to verify the pricer outputs a solution which satisfies the master constraints. Useful for debugging when developing new RCSP pricer for BapCod.
		            In our case it is disabled.
		      \item \texttt{CheckOracleOptimality = false} similar to \texttt{CheckSpOracleFeasibility} but also verifies the optimality of the solution.
	      \end{itemize}

	\item Controlling the column generation procedure:
	      \begin{itemize}
		      \item \texttt{GenerateProperColumns = false} restrict the pricer to generate solutions which respect the the subproblem variable bounds.
		            Although, it probably makes sense to enable this parameter, from our experiment it doesn't play well with the RCSP pricer, which seem to ignore this parameter by generating paths that do not respect the variable bounds of the subproblem.
		      \item \texttt{MaxNbOfStagesInColGenProcedure = 3} controls the number of phases that the RCSP pricer uses.
		            When running in phases $\ge 1$ the RCSP pricer is allowed to use heuristic algorithms to solve simpler pricing instances.
		      \item \texttt{ReducedCostFixingThreshold = 0.0} controls how often the reduced cost fixing procedure of the RCSP pricer is called.
		            Since it was not clear what this procedure does, and whether it is robust or not, it is disabled by setting it to the value $0.0$.
	      \end{itemize}

	\item Controlling the cut generation:
	      \begin{itemize}
		      \item \texttt{MasterCuttingPlanesDepthLimit = -1} controls the max tree depth for cut generation.
		            When set to $-1$ BapCod disables the generation of core cuts.
		      \item \texttt{MaxNbOfCutGeneratedAtEachIter = 0} controls the maxinum number of core cuts added per cut round.
		            Set to $0$ to further enforce disabling the cut generation procedure.
	      \end{itemize}

	\item Controling the branching procedure:
	      \begin{itemize}
		      \item \texttt{StrongBranchingPhaseOne}, \texttt{StrongBranchingPhaseTwo}, \texttt{StrongBranchingPhaseThree}, \texttt{StrongBranchingPhaseFour} controls parameters determining how strong branching is performed for each of the phases.
		            When set to empty strings, e.g. \texttt{StrongBranchingPhaseOne=""}, disables branching for the corresponding phase.
		      \item \texttt{SimplifiedStrongBranchingParameterisation = false} if set to true, allows BapCod to perform strong branching by populating parameters \texttt{StrongBranchingPhaseOne}, \texttt{StrongBranchingPhaseTwo}, \texttt{StrongBranchingPhaseThree}, \texttt{StrongBranchingPhaseFour} to sane defaults.
	      \end{itemize}

	\item Controlling the RCSP dynamic programming labeling pricer:
	      \begin{itemize}
		      \item \texttt{RCSPuseBidirectionalSearch = 2}, called $\phi^\mt{bidir}$ in the original paper, tells the RCSP pricer whether to use the bidirectional search for solving the pricing problem
		      \item \texttt{RCSPapplyReducedCostFixing = 1}, called $\phi^\mt{elim}$ in the original paper, controls the bucket arc elimination procedure the labeling algorithm uses.
		      \item \texttt{RCSPmaxNumOfColsPerExactIteration = 1}, \texttt{RCSPmaxNumOfColsPerIteration = 1},
		            called $\gamma^\mt{exact}, \gamma^\mt{heur}$ in the original paper,
		            controls how many path solutions the pricer generates per pricer iteration respectively in the heuristic phase or in the exact phase.
		            We force the RCSP pricer to generate a single path per pricing iteration.
		      \item \texttt{RCSPallowRoutesWithSameVerticesSet = false} controls whether multiple paths which pass by the same set of vertices are allowed.
		            Shouldn't matter since we are forcing to generate a single path per pricing iteration.
		      \item \texttt{RCSPmaxNumOfEnumSolutionsForMIP = 1}, called $\omega^\mt{MIP}$ in the original paper, controls the threshold at which the number of enumerated path to trigger the solving through a MIP.
		            By setting the parameter to $1$ we are essentially disabling this feature.
		      \item \texttt{RCSPstopCutGenTimeThresholdInPricing = 1e21}, \texttt{RCSPhardTimeThresholdInPricing = 1e21}, called $\tau^\mt{soft}, \tau^\mt{hard}$ in the original paper, controls respectively the soft and hard time threshold for the pricing algorithm.
		            This thresholds control a premature ending of the pricing algorithm in favour of cut generation or branching, if the running time increases above one of these thresholds.
		            Since we want to measure the running time of the algorithm, even when it performs poorly, and we are not interested in generating cuts and branching, we increase these thresholds as high as possible.
		      \item \texttt{RCSPdynamicNGmode = 1} tells BapCod to scale dynamically the ng-sets based on the fractional solution obtained by the column generation (not based on the solution received from the pricing problem).
		      \item \texttt{RCSPinitNGneighbourhoodSize = 8}, \texttt{RCSPmaxNGneighbourhoodSize = 63}, called $\eta^\mt{init}, \eta^\mt{max}$ in the original paper, sets a "soft" elementary constraints that can dynamically be adjusted within the $\eta^\mt{init}, \eta^\mt{max}$ parameters.
		            Raising $\eta^\mt{init}$ can improve the dual bound generated from the pricer, but usually leads to explosion of computation times, especially if it is raised a lot.
		            Raising $\eta^\mt{max}$ can allow the ng-sets to reach higher values, thus improving the dual bound.
		      \item \texttt{RCSPmaxNGaverNeighbourhoodSize = 63}, very similar to parameter $\eta^\mt{max}$, but for the average case.
		            In our case we set this parameter to the same value of $\eta^\mt{max}$.
		      \item \texttt{CutTailingOffThreshold = 0.0000001}, \texttt{CutTailingOffCounterThreshold = 999999}, named $\delta^\mt{gap}, \delta^\mt{num}$ in the original paper, controls the tailing off condition at which BapCod deems cuts ineffective and switches to lower priority (usually more computationally expensive) cuts.
		            Despite their name, these two parameters also affect the pricing algorithm.
		            As pointed out in the original paper, increasing the ng-sets can be seen as a form of "cut generation" since it improves the dual bound.
		            Since we are not interested in cut generation, and we want BapCod to always prefer augmenting the ng-sets, we disable the tailing off condition.
	      \end{itemize}
\end{itemize}
