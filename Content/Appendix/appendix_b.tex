\chapter{Additional details}

\section{A simple dual formulation}\label{sec:cptp-simple-dual-formulation}

A simple dual formulation for the ESPPRC is presented in \cite{beasley1989} and it is here presented and re-adapted for the CPTP problem.

We first need to re-formulate the CPTP as an ESPPRC over a directed network.
We define a new drected network formulation $G_d = \Tuple*{V_d, E_d}$ composed of $N + 1$ nodes, where the depot node is essentially split in two nodes: a source and a sink vertex.
In the new network we use the value $0$ to denote the source version of the depot node, and $N$ its duplicate playing the role of the sink vertex.
More formally, $V_d = \Set*{ 0,\dots, N }$, and the edge set $E_d$ is

\begin{equation}
	\begin{aligned}
		E_d = & \Set*{\Tuple*{i, j} \quad \forall i, j \in V_d,\ i \ne j } \\
		      & \setminus \Set*{ \Tuple*{0, N} }                           \\
		      & \setminus \Set*{ \Tuple*{i, 0} \quad \forall i \in V_d }   \\
		      & \setminus \Set*{ \Tuple*{N, i} \quad \forall i \in V_d }   \\
	\end{aligned}
\end{equation}

which briefly means: all possible pairs $\Tuple*{i, j},\ i \ne j$ excluding: direct connection between $0$ and $N$, and by exluding edges entering node $0$ and flowing out of node $N$.
At each directed edge $\Tuple*{i, j} \in E_d$ we associate a cost $c_{ij} \in \R$.
We define a new set of binary variables $e_{ij} \in \Set*{0, 1} \quad \forall \Tuple*{i, j} \in E_d$, to model solutions for ESPPRC over the directed network.

Is is easy to see that $2 y_i$ in the original CPTP formulation can now be rewritten in the ESPPRC formulation as:

\begin{equation}
	2 y_i = \ExprESPPIngoingEdges{i} + \ExprESPPOutgoingEdges{i} \quad \forall i \in V_0
\end{equation}

Since we are creating a new node, we are also duplicating some edges and we must pay attention that these edges bind to the same CPTP original formulation.
We can bind the new edges to the original CPTP formulation by employing a mutually exclusive constraint of the form:

\begin{equation}
	e_{0i} + e_{iN} \le 1 \quad \forall i \in V_0
\end{equation}

Finally, by setting $c_{ij} = \ExprCptpReducedCost{i}{j} \quad \forall \Tuple*{i, j} \in E_d$, we can rewrite the CPTP original formulation in the ESPPRC IP model:

\begin{align}
	\min_{e} \quad z_\mt{ESPPRC}(e) & =  \sum_{(i, j) \in E_d} \Expr*{ \ExprCptpReducedCost{i}{j} } e_{ij} \label{eq:aB:espprc-obj-function}                                                                                            \\
	                                & B \le \sum_{i \in V_0} \frac{q_i}{2} \Expr*{ \ExprESPPIngoingEdges{i} + \ExprESPPOutgoingEdges{i} }  \le Q                            \label{eq:aB:espprc-resource-upper-bound-constraint}        \\
	                                & \ExprESPPIngoingEdges{i} = \ExprESPPOutgoingEdges{i}                                                \qquad \forall i \in V_0          \label{eq:aB:espprc-flow-conservation-constraint-customers} \\
	                                & \ExprESPPOutgoingEdges[i]{0} = 1                                                                                                      \label{eq:aB:espprc-flow-conservation-constraint-depot1}    \\
	                                & \ExprESPPIngoingEdges[i]{N} = 1                                                                                                       \label{eq:aB:espprc-flow-conservation-constraint-depot2}    \\
	                                & \ExprESPPEdgesWithin[S] \le |S| - 1                                                                  \qquad \forall S \subseteq V_d   \label{eq:aB:espprc-sec-constraints}                        \\
	                                & e_{0i} + e_{iN} \le 1                                                                                \qquad \forall i \in V_0         \label{eq:aB:espprc-cptp-binding}                           \\
	                                & e_{ij}                   \in \lbrace 0, 1 \rbrace                                                    \qquad \forall \Tuple*{i, j} \in E_d    \label{eq:aB:espprc-e-mip-var-bounds}                \\
\end{align}

where, \eqref{eq:aB:espprc-obj-function} is the new objective function where we dropped the dependency on the $y$ MIP variable,
\eqref{eq:aB:espprc-resource-upper-bound-constraint} is the resource bound expressed as a function of only the $e$ MIP variable,
\eqref{eq:aB:espprc-flow-conservation-constraint-customers} is the flow conservation for all vertices except the source and sink node
and \eqref{eq:aB:espprc-flow-conservation-constraint-depot1}, \eqref{eq:aB:espprc-flow-conservation-constraint-depot2} are the flow conservation for respectively the source and sink node,
\eqref{eq:aB:espprc-cptp-binding} avoids forming paths where a single customer is visited,
and finally \eqref{eq:aB:espprc-sec-constraints} are the new subtour elimination constraints which avoid the forming of spurious subtours in unconnected regions of nodes.

\cite{beasley1989} propose to ignore the SEC in \eqref{eq:aB:espprc-sec-constraints} and relaxing \eqref{eq:aB:espprc-resource-upper-bound-constraint}, \eqref{eq:aB:espprc-cptp-binding} in a Lagrangean fashion:

\begin{align}
	\min_{e} \quad z_\mt{ESPP}(e) & = \lambda_0 B - \lambda_1 Q + \sum_{(i, j) \in E_d}  c'_{ij} e_{ij} - \sum_{i \in V_0} \beta_i  \label{eq:aB:esp-relaxed-obj-function} \\
	                              & \ExprESPPIngoingEdges{i} = \ExprESPPOutgoingEdges{i}        \qquad \forall i \in V_0                                                   \\
	                              & \ExprESPPOutgoingEdges[i]{0} = 1                                                                                                       \\
	                              & \ExprESPPIngoingEdges[i]{N} = 1                                                                                                        \\
	                              & e_{ij}                   \in \lbrace 0, 1 \rbrace           \qquad \forall \Tuple*{i, j} \in E_d
\end{align}

where:

\begin{equation}
	c'_{ij} =
	\begin{cases}
		\Expr*{\ExprCptpReducedCost{i}{j}} + \Expr*{\lambda_1 - \lambda_0} \frac{q_i + q_j}{2},           & \texttt{if } i \in V_0,\ j \in V_0 \\
		\Expr*{\ExprCptpReducedCost{i}{j}} + \Expr*{\lambda_1 - \lambda_0} \frac{q_i + q_j}{2} + \beta_j, & \texttt{if } i = 0,\ j \in V_0     \\
		\Expr*{\ExprCptpReducedCost{i}{j}} + \Expr*{\lambda_1 - \lambda_0} \frac{q_i + q_j}{2} + \beta_i, & \texttt{if } i \in V_0,\ j = N
	\end{cases}
\end{equation}

and $\lambda_0 \ge 0, \lambda_1 \ge 0, \beta_i \ge 0 \quad \forall i \in V_0$ are the respective Lagrange multipliers.
The above IP describes an elementary shortest path problem, where the associated weights may be negative.

\cite{beasley1989} propose a subgradient procedure to obtain feasible lower bound for the original CPTP problem.
Since the ESPP problem with arbitrary weights is an NP-hard problem, they suggest to use a standard Dijkstra algorithm, but in order to do so, the lagrange multipliers must be set such that $c'_{ij} \ge 0$ is satisfied.
By considering only lagrange multipliers achieving $c'_{ij} \ge 0$ has the additional benefit that neglecting the SEC were justified since these would be automatically satisfied.
The advantage of this approach is that it allows for the usage of simple of the shelf algorithms to obtain lower bounds for the CPTP.
But, unfortunately, the lower bounds generated by such approach are unsatisfactory at best.
As pointed out in \cite{righini2004}, solving the ESPPRC problem through Lagrangean relaxation is effective only when the Lagrangean subproblem is easy, i.e. for which $c'_{ij} \ge 0$ over a good portion of the lagrange multipliers search space.

\section{The three-index flow formulation}
\label{sec:intro-cvrp-three-index-flow-formulation}

The three-index flow formulation, first presented in \textcite{toth2002},
is an IP model employing $O(N^2 K + N K)$ binary variables.

We define a set of binary variables $x_{ijk} \in \Set*{0, 1}, (i, j) \in E, k = 1, \dots, K$, to encode whether vehicle $k$ traverses edge $(i, j)$,
and another set of binary variables $y_{ik} \in \Set*{0, 1}, i \in V, k = 1, \dots, K$ to encode whether truck $k$ serves node $i \in V$.
We can therefore define the three-index flow formulation through an IP model as follows:

\begin{align}
	\min_{x, y} \quad z_\mt{3F}(x, y) & =  \sum_{k = 1}^K \sum_{(i, j) \in E} d_{ij} x_{ijk} \label{eq:three-index-flow-obj-func}                                                                                                                          \\
	                                  & \sum_{k = 1}^K y_{ik} = 1                                                                 & \quad \forall i \in V_0                                              \label{eq:three-index-flow-all-customers-visited} \\
	                                  & \sum_{k = 1}^K y_{0k} = K                                                                 & \label{eq:three-index-flow-tour-starts-and-ends-at-depot}                                                              \\
	                                  & \sum_{\EqStackTwo{j \in V}{(i, j) \in E}} x_{ijk} = 2 y_{ik}                              & \quad \forall i \in V,\ k = 1, \dots, K \label{eq:three-index-flow-force-visited-customer-if-flow}                     \\
	                                  & \sum_{i \in V} q_i y_{ik} \le Q                                                           & \quad \forall k = 1, \dots, K \label{eq:three-index-flow-force-resource-upper-bound}                                   \\
	                                  & \sum_{i, j \in S} x_{ijk} \le |S| - 1                                                     & \quad \EqStackTwo{\forall S \subseteq V, |S| \ge 2}{k = 1, \dots, K} \label{eq:three-index-flow-secs}                  \\
	                                  & x_{ijk}                   \in \Set*{0, 1}                                                 & \quad \forall (i, j) \in E,\ k = 1, \dots, K             \label{eq:three-index-flow-x-mip-var-bounds}                  \\
	                                  & y_{ik}                    \in \Set*{0, 1}                                                 & \quad \forall i \in V,k = 1, \dots, K  \label{eq:three-index-flow-y-mip-var-bounds}
\end{align}

where $z_\mt{3F}(x, y)$, as defined in \eqref{eq:three-index-flow-obj-func}, is the objective function to be minimized (i.e. the overall travel distance).
Constraint \eqref{eq:three-index-flow-all-customers-visited} forces all customers to be served exactly once.
Constraint \eqref{eq:three-index-flow-tour-starts-and-ends-at-depot} forces all the truck tours to start at the depot and end at the same spot.
Constraint \eqref{eq:three-index-flow-force-visited-customer-if-flow} binds the $y_{ik}$ variables to the corresponding $x_{ijk}$ variables, by ensuring that if a truck's route passes through a vertex, then the corresponding node is marked as visited.
Constraint \eqref{eq:three-index-flow-force-resource-upper-bound} is the resource upper bound contraint and it ensures that the demand served by each truck does not exceed the truck capacity.
Constraints \eqref{eq:three-index-flow-secs} are the TSP subtour elimination constraints (SECs) and are used to avoid the formation of spurious unconnected subtours.
Finally, Constraints \eqref{eq:three-index-flow-x-mip-var-bounds}, \eqref{eq:three-index-flow-y-mip-var-bounds} bound and force integrality for the IP variables.

Since the number of SECs is exponential in the number of nodes $N$, they are usually not inserted statically in the model but are generated lazily within the running time of the resolution process.

There's an important observation to be made on constraint \eqref{eq:three-index-flow-tour-starts-and-ends-at-depot}.
By using the equality sign, we're forcing solutions to use all the available $K$ trucks, even though better solutions making use of less trucks may exist.
In our case, we decided to fix the number of routes in the CVRP formulation since it seems that this is the most agreed contention in the literature.
Some authors, instead, prefer a different CVRP formulation, by not fixing the number of routes, and by essentially using a less-than-sign in place of the equality.

The three-index flow formulation is usually solved through the usage of a standard Branch \& Cut framework approach.
Modern CVRP solvers, instead, rely on a different mathematical formulation and employ a  mostly Branch \& Price based-approach (although hybridization are also possible).
The Set Partitioning (SP) formulation is the main starting point employed by Branch \& Price solvers.
In this thesis we will mostly concentrate on Branch \& Price approaches for the CVRP.
In the next subsection we will introduce the set partitioning formulation, and in the remainder of the section
we will briefly introduce the key ingredients of modern Branch \& Price solvers.

\begin{comment}
\cite{jepsen2011}
Although the main focus of this thesis is exact solution methods, it is impor-
tant to remember that in real life the computational time needed to find the
optimal solution is not always available therefore it is important that the
exact solution algorithms can find good solutions within reasonable time.
Danna and Le Pape [18] have shown how to integrate the Branch-and-Price
algorithm with a local search framework. This integration helps the bcp
algorithm with finding good integer solutions in the early stages of the al-
gorithm. The method has show to result in reasonable good solutions for
the vrptw. Prescott-Gagnon et al. [55] have improved the heuristic ap-
proach for bcp algorithms further by integrating the bcp algorithm with
large neighbourhood search. For bac algorithms methods such as local
branching introduced by Fischetti and Lodi [28] and the feasibility pump
introduced by Fischetti et al. [29] can be used to find fast and good solu-
tions. The main benefit of the exact solution approach is that it provides
both an upper and lower bound.
Though when a fast good solution is needed a heuristics such as the
adaptive large scale neighbourhood search by Pisinger and Ropke [54] for
cvrp, vrptw and many other Vehicle Routing variants or the local search
heuristic by Zachariadis and Kiranoudis [65] are preferable.
\end{comment}
